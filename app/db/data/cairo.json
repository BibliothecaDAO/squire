[
  {
    "pageContent": "use gas::withdraw_gas;\nuse box::BoxTrait;\n\nextern type Array<T>;\nextern fn array_new<T>() -> Array<T> nopanic;\nextern fn array_append<T>(ref arr: Array<T>, value: T) nopanic;\nextern fn array_pop_front<T>(ref arr: Array<T>) -> Option<Box<T>> nopanic;\nextern fn array_snapshot_pop_front<T>(ref arr: @Array<T>) -> Option<Box<@T>> nopanic;\n#[panic_with('Index out of bounds', array_at)]\nextern fn array_get<T>(\n    arr: @Array<T>, index: usize\n) -> Option<Box<@T>> implicits(RangeCheck) nopanic;\nextern fn array_len<T>(arr: @Array<T>) -> usize nopanic;\n\ntrait ArrayTrait<T> {\n    fn new() -> Array<T>;\n    fn append(ref self: Array<T>, value: T);\n    fn pop_front(ref self: Array<T>) -> Option<T> nopanic;\n    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>>;\n    fn at(self: @Array<T>, index: usize) -> @T;\n    fn len(self: @Array<T>) -> usize;\n    fn is_empty(self: @Array<T>) -> bool;\n    fn span(self: @Array<T>) -> Span<T>;\n}\nimpl ArrayImpl<T> of ArrayTrait::<T> {\n    #[inline(always)]\n    fn new() -> Array<T> {\n        array_new()\n    }\n    #[inline(always)]\n    fn append(ref self: Array<T>, value: T) {\n        array_append(ref self, value)\n    }\n    #[inline(always)]\n    fn pop_front(ref self: Array<T>) -> Option<T> nopanic {\n        match array_pop_front(ref self) {\n            Option::Some(x) => Option::Some(x.unbox()),\n            Option::None(_) => Option::None(()),\n        }\n    }\n    #[inline(always)]\n    fn get(self: @Array<T>, index: usize) -> Option<Box<@T>> {\n        array_get(self, index)\n    }\n    fn at(self: @Array<T>, index: usize) -> @T {\n        array_at(self, index).unbox()\n    }\n    #[inline(always)]\n    fn len(self: @Array<T>) -> usize {\n        array_len(self)\n    }\n    #[inline(always)]\n    fn is_empty(self: @Array<T>) -> bool {\n        self.len() == 0_usize\n    }\n\n    #[inline(always)]\n    fn span(self: @Array<T>) -> Span<T> {\n        Span { snapshot: self }\n    }\n}\n\n// Impls for common generic types\nimpl ArrayDrop<T, impl TDrop: Drop::<T>> of Drop::<Array::<T>>;\n\n\n// Span.\nstruct Span<T> {\n    snapshot: @Array<T>\n}\n\nimpl SpanCopy<T> of Copy::<Span::<T>>;\nimpl SpanDrop<T> of Drop::<Span::<T>>;\n\ntrait SpanTrait<T> {\n    fn pop_front(ref self: Span<T>) -> Option<@T>;\n    fn get(self: Span<T>, index: usize) -> Option<Box<@T>>;\n    fn at(self: Span<T>, index: usize) -> @T;\n    fn len(self: Span<T>) -> usize;\n    fn is_empty(self: Span<T>) -> bool;\n}\nimpl SpanImpl<T> of SpanTrait::<T> {\n    #[inline(always)]\n    fn pop_front(ref self: Span<T>) -> Option<@T> {\n        let mut snapshot = self.snapshot;\n        let item = array_snapshot_pop_front(ref snapshot);\n        self = Span { snapshot };\n        match item {\n            Option::Some(x) => Option::Some(x.unbox()),\n            Option::None(_) => Option::None(()),\n        }\n    }\n\n    #[inline(always)]\n    fn get(self: Span<T>, index: usize) -> Option<Box<@T>> {\n        array_get(self.snapshot, index)\n    }\n    #[inline(always)]\n    fn at(self: Span<T>, index: usize) -> @T {\n        array_at(self.snapshot, index).unbox()\n    }\n    #[inline(always)]\n    fn len(self: Span<T>) -> usize {\n        array_len(self.snapshot)\n    }\n    #[inline(always)]\n    fn is_empty(self: Span<T>) -> bool {\n        self.len() == 0_usize\n    }\n}\n\nimpl ArrayTCloneImpl<T, impl TClone: Clone::<T>, impl TDrop: Drop::<T>> of Clone::<Array<T>> {\n    fn clone(self: @Array<T>) -> Array<T> {\n        let mut response = array_new();\n        clone_loop(self.span(), ref response);\n        response\n    }\n}\n\n// TODO(spapini): Remove TDrop. It is necessary to get rid of response in case of panic.\nfn clone_loop<T, impl TClone: Clone::<T>, impl TDrop: Drop::<T>>(\n    mut span: Span<T>, ref response: Array<T>\n) {\n    match withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = array_new();\n            array_append(ref data, 'Out of gas');\n            panic(data);\n        },\n    }\n    match span.pop_front() {\n        Option::Some(v) => {\n            response.append(TClone::clone(v));\n            clone_loop(span, ref response);\n        },\n        Option::None(_) => {},\n    }\n}\n",
    "metadata": {
      "name": "array.cairo"
    }
  },
  {
    "pageContent": "extern type Box<T>;\nimpl BoxTCopy<T, impl TCopy: Copy::<T>> of Copy::<Box::<T>>;\nimpl BoxTDrop<T, impl TDrop: Drop::<T>> of Drop::<Box::<T>>;\n\n// These functions are only exposed in the corelib through the trait below since calling them\n// directly with tuples panics due to auto unpacking of the tuple.\n// TODO(Gil): Expose in the core lib when the described behaviour is fixed.\nextern fn into_box<T>(value: T) -> Box<T> nopanic;\nextern fn unbox<T>(box: Box<T>) -> T nopanic;\n\ntrait BoxTrait<T> {\n    fn new(value: T) -> Box<T> nopanic;\n    fn unbox(self: Box<T>) -> T nopanic;\n}\n\nimpl BoxImpl<T> of BoxTrait::<T> {\n    #[inline(always)]\n    fn new(value: T) -> Box<T> nopanic {\n        into_box(value)\n    }\n    #[inline(always)]\n    fn unbox(self: Box<T>) -> T nopanic {\n        unbox(self)\n    }\n}\n",
    "metadata": {
      "name": "box.cairo"
    }
  },
  {
    "pageContent": "trait Clone<T> {\n    fn clone(self: @T) -> T;\n}\n\nimpl TCopyClone<T, impl TCopy: Copy::<T>> of Clone::<T> {\n    fn clone(self: @T) -> T {\n        *self\n    }\n}\n",
    "metadata": {
      "name": "clone.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nuse traits::Into;\nuse starknet::ContractAddressIntoFelt252;\nuse option::Option;\n\n// Usage:\n//\n// use debug::PrintTrait;\n//\n// 1.print();\n//\n// (1 == 2).print();\n//\n// get_caller_address().print();\n//\n// let mut arr = ArrayTrait::new();\n// arr.append('1234567890123456789012345678901');\n// arr.append('Sca');\n// arr.append('SomeVeryLongMessage');\n// arr.print();\n\nextern fn print(message: Array<felt252>) nopanic;\n\nfn print_felt252(message: felt252) {\n    let mut arr = ArrayTrait::new();\n    arr.append(message);\n    print(arr);\n}\n\ntrait PrintTrait<T> {\n    fn print(self: T);\n}\n\nimpl Felt252PrintImpl of PrintTrait::<felt252> {\n    fn print(self: felt252) {\n        print_felt252(self);\n    }\n}\n\nimpl BoolPrintImpl of PrintTrait::<bool> {\n    fn print(self: bool) {\n        if self {\n            'true'.print();\n        } else {\n            'false'.print();\n        }\n    }\n}\n\nimpl ContractAddressPrintImpl of PrintTrait::<starknet::ContractAddress> {\n    fn print(self: starknet::ContractAddress) {\n        self.into().print();\n    }\n}\n\nimpl U8PrintImpl of PrintTrait::<u8> {\n    fn print(self: u8) {\n        self.into().print();\n    }\n}\n\nimpl U64PrintImpl of PrintTrait::<u64> {\n    fn print(self: u64) {\n        self.into().print();\n    }\n}\n\nimpl U128PrintImpl of PrintTrait::<u128> {\n    fn print(self: u128) {\n        self.into().print();\n    }\n}\n\nimpl U256PrintImpl of PrintTrait::<u256> {\n    fn print(self: u256) {\n        self.low.into().print();\n        self.high.into().print();\n    }\n}\n\nimpl ArrayGenericPrintImpl of PrintTrait::<Array::<felt252>> {\n    fn print(mut self: Array::<felt252>) {\n        print(self);\n    }\n}\n",
    "metadata": {
      "name": "debug.cairo"
    }
  },
  {
    "pageContent": "extern type Felt252Dict<T>;\nextern type SquashedFelt252Dict<T>;\nimpl SquashedFelt252DictDrop<T, impl TDrop: Drop::<T>> of Drop::<SquashedFelt252Dict::<T>>;\n\nextern fn felt252_dict_new<T>() -> Felt252Dict<T> implicits(SegmentArena) nopanic;\nextern fn felt252_dict_write<T>(ref dict: Felt252Dict<T>, key: felt252, value: T) nopanic;\nextern fn felt252_dict_read<T>(ref dict: Felt252Dict<T>, key: felt252) -> T nopanic;\n\n/// Squashes the dictionary and returns SquashedFelt252Dict.\n///\n/// NOTE: Never use this libfunc directly. Use Felt252DictTrait::squash() instead. Using this\n/// libfunc directly will result in multiple unnecessary copies of the libfunc in the compiled CASM\n/// code.\nextern fn felt252_dict_squash<T>(\n    dict: Felt252Dict<T>\n) -> SquashedFelt252Dict<T> implicits(RangeCheck, GasBuiltin, SegmentArena) nopanic;\n\ntrait Felt252DictTrait<T> {\n    fn new() -> Felt252Dict<T>;\n    fn insert(ref self: Felt252Dict<T>, key: felt252, value: T);\n    fn get(ref self: Felt252Dict<T>, key: felt252) -> T;\n    fn squash(self: Felt252Dict<T>) -> SquashedFelt252Dict<T> nopanic;\n}\nimpl Felt252DictImpl<T> of Felt252DictTrait::<T> {\n    fn new() -> Felt252Dict<T> {\n        felt252_dict_new()\n    }\n    fn insert(ref self: Felt252Dict<T>, key: felt252, value: T) {\n        felt252_dict_write(ref self, key, value)\n    }\n    fn get(ref self: Felt252Dict<T>, key: felt252) -> T {\n        felt252_dict_read(ref self, key)\n    }\n    #[inline(never)]\n    fn squash(self: Felt252Dict<T>) -> SquashedFelt252Dict<T> nopanic {\n        felt252_dict_squash(self)\n    }\n}\n\nimpl Felt252DictDestruct<T, impl TDrop: Drop::<T>> of Destruct::<Felt252Dict::<T>> {\n    #[inline(always)]\n    fn destruct(self: Felt252Dict::<T>) nopanic {\n        self.squash();\n    }\n}\n",
    "metadata": {
      "name": "dict.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\nmod StarkCurve {\n    /// The STARK Curve is defined by the equation `y^2 = x^3 + ALPHA*x + BETA`.\n    const ALPHA: felt252 = 1;\n    /// The STARK Curve is defined by the equation `y^2 = x^3 + ALPHA*x + BETA`.\n    const BETA: felt252 = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89;\n    /// The order (number of points) of the STARK Curve.\n    const ORDER: felt252 = 0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f;\n    /// The x coordinate of the generator point used in the ECDSA signature.\n    const GEN_X: felt252 = 0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca;\n    /// The y coordinate of the generator point used in the ECDSA signature.\n    const GEN_Y: felt252 = 0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f;\n}\n\nextern type EcOp;\n#[derive(Copy, Drop)]\nextern type EcPoint;\ntype NonZeroEcPoint = NonZero<EcPoint>;\n\n/// Returns the zero point of the curve (\"the point at infinity\").\nextern fn ec_point_zero() -> EcPoint nopanic;\n/// Constructs a non-zero point from its (x, y) coordinates.\n///\n/// * `ec_point_try_new_nz` returns `None` if the point (x, y) is not on the curve.\n/// * `ec_point_new_nz` panics in that case.\n#[panic_with('not on EC', ec_point_new_nz)]\nextern fn ec_point_try_new_nz(x: felt252, y: felt252) -> Option<NonZeroEcPoint> nopanic;\n\n#[inline(always)]\nfn ec_point_try_new(x: felt252, y: felt252) -> Option<EcPoint> {\n    match ec_point_try_new_nz(:x, :y) {\n        Option::Some(pt) => Option::Some(unwrap_non_zero(pt)),\n        Option::None(()) => Option::None(()),\n    }\n}\n\nfn ec_point_new(x: felt252, y: felt252) -> EcPoint {\n    unwrap_non_zero(ec_point_new_nz(:x, :y))\n}\n\nextern fn ec_point_from_x_nz(x: felt252) -> Option<NonZeroEcPoint> implicits(RangeCheck) nopanic;\n\n#[inline(always)]\nfn ec_point_from_x(x: felt252) -> Option<EcPoint> {\n    match ec_point_from_x_nz(:x) {\n        Option::Some(pt) => Option::Some(unwrap_non_zero(pt)),\n        Option::None(()) => Option::None(()),\n    }\n}\n\nextern fn ec_point_unwrap(p: NonZeroEcPoint) -> (felt252, felt252) nopanic;\n/// Computes the negation of an elliptic curve point (-p).\nextern fn ec_neg(p: EcPoint) -> EcPoint nopanic;\n/// Checks whether the given `EcPoint` is the zero point.\nextern fn ec_point_is_zero(p: EcPoint) -> IsZeroResult<EcPoint> nopanic;\n\n/// Converts `p` to `NonZeroEcPoint`. Panics if `p` is the zero point.\nfn ec_point_non_zero(p: EcPoint) -> NonZeroEcPoint {\n    match ec_point_is_zero(p) {\n        IsZeroResult::Zero(()) => {\n            let mut data = ArrayTrait::new();\n            data.append('Zero point');\n            panic(data)\n        },\n        IsZeroResult::NonZero(p_nz) => p_nz,\n    }\n}\n\n// EC state.\n\n// TODO(lior): Allow explicit clone() for EcState, since we don't allow implicit dup (Copy).\n#[derive(Drop)]\nextern type EcState;\n\n/// Initializes an EC computation with the zero point.\nextern fn ec_state_init() -> EcState nopanic;\n/// Adds a point to the computation.\nextern fn ec_state_add(ref s: EcState, p: NonZeroEcPoint) nopanic;\n/// Finalizes the EC computation and returns the result (returns `None` if the result is the\n/// zero point).\nextern fn ec_state_try_finalize_nz(s: EcState) -> Option<NonZeroEcPoint> nopanic;\n/// Adds the product p * m to the state.\nextern fn ec_state_add_mul(ref s: EcState, m: felt252, p: NonZeroEcPoint) implicits(EcOp) nopanic;\n\n/// Finalizes the EC computation and returns the result.\n#[inline(always)]\nfn ec_state_finalize(s: EcState) -> EcPoint nopanic {\n    match ec_state_try_finalize_nz(s) {\n        Option::Some(pt) => unwrap_non_zero(pt),\n        Option::None(()) => ec_point_zero(),\n    }\n}\n\n/// Computes the product of an EC point `p` by the given scalar `m`.\nfn ec_mul(p: EcPoint, m: felt252) -> EcPoint {\n    match ec_point_is_zero(p) {\n        IsZeroResult::Zero(()) => p,\n        IsZeroResult::NonZero(p_nz) => {\n            let mut state = ec_state_init();\n            ec_state_add_mul(ref state, m, p_nz);\n            ec_state_finalize(state)\n        }\n    }\n}\n\nimpl EcPointAdd of Add::<EcPoint> {\n    /// Computes the sum of two points on the curve.\n    // TODO(lior): Implement using a libfunc to make it more efficient.\n    fn add(p: EcPoint, q: EcPoint) -> EcPoint {\n        let p_nz = match ec_point_is_zero(p) {\n            IsZeroResult::Zero(()) => {\n                return q;\n            },\n            IsZeroResult::NonZero(pt) => pt,\n        };\n        let q_nz = match ec_point_is_zero(q) {\n            IsZeroResult::Zero(()) => {\n                return p;\n            },\n            IsZeroResult::NonZero(pt) => pt,\n        };\n        let mut state = ec_state_init();\n        ec_state_add(ref state, p_nz);\n        ec_state_add(ref state, q_nz);\n        ec_state_finalize(state)\n    }\n}\n\nimpl EcPointAddEq of AddEq::<EcPoint> {\n    #[inline(always)]\n    fn add_eq(ref self: EcPoint, other: EcPoint) {\n        self = Add::add(self, other);\n    }\n}\n\nimpl EcPointSub of Sub::<EcPoint> {\n    /// Computes the difference between two points on the curve.\n    fn sub(p: EcPoint, q: EcPoint) -> EcPoint {\n        match ec_point_is_zero(q) {\n            IsZeroResult::Zero(()) => {\n                // p - 0 = p.\n                return p;\n            },\n            IsZeroResult::NonZero(_) => {},\n        };\n        // p - q = p + (-q).\n        p + ec_neg(q)\n    }\n}\n\nimpl EcPointSubEq of SubEq::<EcPoint> {\n    #[inline(always)]\n    fn sub_eq(ref self: EcPoint, other: EcPoint) {\n        self = Sub::sub(self, other);\n    }\n}\n",
    "metadata": {
      "name": "ec.cairo"
    }
  },
  {
    "pageContent": "// Checks if (`signature_r`, `signature_s`) is a valid ECDSA signature for the given `public_key`\n// on the given `message`.\n//\n// Note: the verification algorithm implemented by this function slightly deviates from the\n// standard ECDSA.\n// While this does not allow to create valid signatures if one does not possess the private key,\n// it means that the signature algorithm used should be modified accordingly.\n// Namely, it should check that `r, s < StarkCurve::ORDER`.\n//\n// Arguments:\n// * `message_hash` - the signed message.\n// * `public_key` - the public key corresponding to the key with which the message was signed.\n// * `signature_r` - the `r` component of the ECDSA signature.\n// * `signature_s` - the `s` component of the ECDSA signature.\n//\n// Returns:\n//   `true` if the signature is valid and `false` otherwise.\n// TODO(lior): Make this function nopanic once possible.\nfn check_ecdsa_signature(\n    message_hash: felt252, public_key: felt252, signature_r: felt252, signature_s: felt252\n) -> bool {\n    // TODO(lior): Change to || once short circuiting is supported.\n\n    // Check that s != 0 (mod StarkCurve.ORDER).\n    if (signature_s == 0) {\n        return false;\n    }\n    if (signature_s == ec::StarkCurve::ORDER) {\n        return false;\n    }\n    if (signature_r == ec::StarkCurve::ORDER) {\n        return false;\n    }\n\n    // Check that the public key is the x coordinate of a point on the curve and get such a point.\n    let public_key_point = match ec::ec_point_from_x(public_key) {\n        Option::Some(point) => point,\n        Option::None(()) => {\n            return false;\n        },\n    };\n\n    // Check that `r` is the x coordinate of a point on the curve and get such a point.\n    // Note that this ensures that `r != 0`.\n    let signature_r_point = match ec::ec_point_from_x(signature_r) {\n        Option::Some(point) => point,\n        Option::None(()) => {\n            return false;\n        },\n    };\n\n    // Retrieve the generator point.\n    let gen_point = match ec_point_try_new(ec::StarkCurve::GEN_X, ec::StarkCurve::GEN_Y) {\n        Option::Some(point) => point,\n        Option::None(()) => {\n            return false;\n        },\n    };\n\n    // To verify ECDSA, obtain:\n    //   zG = z * G, where z is the message and G is a generator of the EC.\n    //   rQ = r * Q, where Q.x = public_key.\n    //   sR = s * R, where R.x = r.\n    // and check that:\n    //   zG +/- rQ = +/- sR, or more efficiently that:\n    //   (zG +/- rQ).x = sR.x.\n\n    let sR: EcPoint = ec_mul(signature_r_point, signature_s);\n    let sR_x = match ec_point_is_zero(sR) {\n        IsZeroResult::Zero(()) => {\n            return false;\n        },\n        IsZeroResult::NonZero(pt) => {\n            let (x, y) = ec_point_unwrap(pt);\n            x\n        },\n    };\n\n    let zG: EcPoint = ec_mul(gen_point, message_hash);\n    let rQ: EcPoint = ec_mul(public_key_point, signature_r);\n    match ec_point_is_zero(zG + rQ) {\n        IsZeroResult::Zero(()) => {},\n        IsZeroResult::NonZero(pt) => {\n            let (x, y) = ec_point_unwrap(pt);\n            if (x == sR_x) {\n                return true;\n            }\n        },\n    };\n\n    match ec_point_is_zero(zG - rQ) {\n        IsZeroResult::Zero(()) => {},\n        IsZeroResult::NonZero(pt) => {\n            let (x, y) = ec_point_unwrap(pt);\n            if (x == sR_x) {\n                return true;\n            }\n        },\n    };\n\n    return false;\n}\n",
    "metadata": {
      "name": "ecdsa.cairo"
    }
  },
  {
    "pageContent": "#[derive(Copy, Drop)]\nextern type BuiltinCosts;\nextern type GasBuiltin;\n\nextern fn withdraw_gas() -> Option<()> implicits(RangeCheck, GasBuiltin) nopanic;\nextern fn withdraw_gas_all(\n    costs: BuiltinCosts\n) -> Option<()> implicits(RangeCheck, GasBuiltin) nopanic;\nextern fn get_builtin_costs() -> BuiltinCosts nopanic;\n",
    "metadata": {
      "name": "gas.cairo"
    }
  },
  {
    "pageContent": "use traits::Into;\nuse starknet::ContractAddressIntoFelt252;\nuse starknet::ContractAddress;\n\nextern type Pedersen;\n\nextern fn pedersen(a: felt252, b: felt252) -> felt252 implicits(Pedersen) nopanic;\n\ntrait LegacyHash<T> {\n    fn hash(state: felt252, value: T) -> felt252;\n}\n\nimpl LegacyHashFelt252 of LegacyHash::<felt252> {\n    fn hash(state: felt252, value: felt252) -> felt252 {\n        pedersen(state, value)\n    }\n}\n\nimpl LegacyHashBool of LegacyHash::<bool> {\n    fn hash(state: felt252, value: bool) -> felt252 {\n        LegacyHash::<felt252>::hash(state, if value {\n            1\n        } else {\n            0\n        })\n    }\n}\n\nimpl LegacyHashU8 of LegacyHash::<u8> {\n    fn hash(state: felt252, value: u8) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl LegacyHashU16 of LegacyHash::<u16> {\n    fn hash(state: felt252, value: u16) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl LegacyHashU32 of LegacyHash::<u32> {\n    fn hash(state: felt252, value: u32) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl LegacyHashU64 of LegacyHash::<u64> {\n    fn hash(state: felt252, value: u64) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl LegacyHashU128 of LegacyHash::<u128> {\n    fn hash(state: felt252, value: u128) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl LegacyHashU256 of LegacyHash::<u256> {\n    fn hash(state: felt252, value: u256) -> felt252 {\n        let state = LegacyHash::<u128>::hash(state, value.low);\n        LegacyHash::<u128>::hash(state, value.high)\n    }\n}\n\nimpl LegacyHashContractAddress of LegacyHash::<starknet::ContractAddress> {\n    fn hash(state: felt252, value: starknet::ContractAddress) -> felt252 {\n        LegacyHash::<felt252>::hash(state, value.into())\n    }\n}\n\nimpl TupleSize0LegacyHash of LegacyHash::<()> {\n    fn hash(state: felt252, value: ()) -> felt252 {\n        state\n    }\n}\n\nimpl TupleSize1LegacyHash<E0, impl E0LegacyHash: LegacyHash::<E0>> of LegacyHash::<(E0, )> {\n    fn hash(state: felt252, value: (E0, )) -> felt252 {\n        let (e0, ) = value;\n        E0LegacyHash::hash(state, e0)\n    }\n}\n\nimpl TupleSize2LegacyHash<E0,\nE1,\nimpl E0LegacyHash: LegacyHash::<E0>,\nimpl E1LegacyHash: LegacyHash::<E1>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Drop: Drop::<E1>> of LegacyHash::<(E0, E1)> {\n    fn hash(state: felt252, value: (E0, E1, )) -> felt252 {\n        let (e0, e1) = value;\n        let state = E0LegacyHash::hash(state, e0);\n        E1LegacyHash::hash(state, e1)\n    }\n}\n\nimpl TupleSize3LegacyHash<E0,\nE1,\nE2,\nimpl E0LegacyHash: LegacyHash::<E0>,\nimpl E1LegacyHash: LegacyHash::<E1>,\nimpl E2LegacyHash: LegacyHash::<E2>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Drop: Drop::<E2>,\n> of LegacyHash::<(E0, E1, E2)> {\n    fn hash(state: felt252, value: (E0, E1, E2)) -> felt252 {\n        let (e0, e1, e2) = value;\n        let state = E0LegacyHash::hash(state, e0);\n        let state = E1LegacyHash::hash(state, e1);\n        E2LegacyHash::hash(state, e2)\n    }\n}\n\nimpl TupleSize4LegacyHash<E0,\nE1,\nE2,\nE3,\nimpl E0LegacyHash: LegacyHash::<E0>,\nimpl E1LegacyHash: LegacyHash::<E1>,\nimpl E2LegacyHash: LegacyHash::<E2>,\nimpl E3LegacyHash: LegacyHash::<E3>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Drop: Drop::<E2>,\nimpl E3Drop: Drop::<E3>,\n> of LegacyHash::<(E0, E1, E2, E3)> {\n    fn hash(state: felt252, value: (E0, E1, E2, E3)) -> felt252 {\n        let (e0, e1, e2, e3) = value;\n        let state = E0LegacyHash::hash(state, e0);\n        let state = E1LegacyHash::hash(state, e1);\n        let state = E2LegacyHash::hash(state, e2);\n        E3LegacyHash::hash(state, e3)\n    }\n}\n",
    "metadata": {
      "name": "hash.cairo"
    }
  },
  {
    "pageContent": "use result::ResultTrait;\nuse result::ResultTraitImpl;\nuse option::OptionTrait;\nuse option::OptionTraitImpl;\nuse traits::Into;\nuse traits::TryInto;\n\n#[derive(Copy, Drop)]\nextern type u128;\nextern fn u128_const<value>() -> u128 nopanic;\n\nenum U128sFromFelt252Result {\n    Narrow: u128,\n    Wide: (u128, u128),\n}\nextern fn u128s_from_felt252(a: felt252) -> U128sFromFelt252Result implicits(RangeCheck) nopanic;\n\n#[panic_with('u128_from OF', u128_from_felt252)]\nfn u128_try_from_felt252(a: felt252) -> Option<u128> implicits(RangeCheck) nopanic {\n    match u128s_from_felt252(a) {\n        U128sFromFelt252Result::Narrow(x) => Option::Some(x),\n        U128sFromFelt252Result::Wide(x) => Option::None(()),\n    }\n}\n\nextern fn u128_to_felt252(a: u128) -> felt252 nopanic;\n\nextern fn u128_overflowing_add(\n    a: u128, b: u128\n) -> Result<u128, u128> implicits(RangeCheck) nopanic;\nextern fn u128_overflowing_sub(\n    a: u128, b: u128\n) -> Result<u128, u128> implicits(RangeCheck) nopanic;\n\nfn u128_wrapping_add(a: u128, b: u128) -> u128 implicits(RangeCheck) nopanic {\n    match u128_overflowing_add(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nextern fn u128_wide_mul(a: u128, b: u128) -> (u128, u128) implicits(RangeCheck) nopanic;\nextern fn u128_sqrt(value: u128) -> u128 implicits(RangeCheck) nopanic;\n\nfn u128_overflowing_mul(a: u128, b: u128) -> (u128, bool) implicits(RangeCheck) nopanic {\n    let (top_word, bottom_word) = u128_wide_mul(a, b);\n    match u128_to_felt252(top_word) {\n        0 => (bottom_word, false),\n        _ => (bottom_word, true),\n    }\n}\n\n\nfn u128_checked_add(a: u128, b: u128) -> Option<u128> implicits(RangeCheck) nopanic {\n    match u128_overflowing_add(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U128Add of Add::<u128> {\n    fn add(a: u128, b: u128) -> u128 {\n        u128_overflowing_add(a, b).expect('u128_add Overflow')\n    }\n}\nimpl U128AddEq of AddEq::<u128> {\n    #[inline(always)]\n    fn add_eq(ref self: u128, other: u128) {\n        self = Add::add(self, other);\n    }\n}\n\n#[panic_with('u128_sub OF', u128_sub)]\nfn u128_checked_sub(a: u128, b: u128) -> Option<u128> implicits(RangeCheck) nopanic {\n    match u128_overflowing_sub(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U128Sub of Sub::<u128> {\n    fn sub(a: u128, b: u128) -> u128 {\n        u128_overflowing_sub(a, b).expect('u128_sub Overflow')\n    }\n}\nimpl U128SubEq of SubEq::<u128> {\n    #[inline(always)]\n    fn sub_eq(ref self: u128, other: u128) {\n        self = Sub::sub(self, other);\n    }\n}\n\nfn u128_checked_mul(a: u128, b: u128) -> Option<u128> implicits(RangeCheck) nopanic {\n    let (top_word, bottom_word) = u128_wide_mul(a, b);\n    match u128_to_felt252(top_word) {\n        0 => Option::Some(bottom_word),\n        _ => Option::None(()),\n    }\n}\n\nimpl U128Mul of Mul::<u128> {\n    fn mul(a: u128, b: u128) -> u128 {\n        u128_checked_mul(a, b).expect('u128_mul Overflow')\n    }\n}\nimpl U128MulEq of MulEq::<u128> {\n    #[inline(always)]\n    fn mul_eq(ref self: u128, other: u128) {\n        self = Mul::mul(self, other);\n    }\n}\n\n#[panic_with('u128 is 0', u128_as_non_zero)]\nfn u128_try_as_non_zero(a: u128) -> Option<NonZero<u128>> implicits() nopanic {\n    match u128_is_zero(a) {\n        IsZeroResult::Zero(()) => Option::None(()),\n        IsZeroResult::NonZero(x) => Option::Some(x),\n    }\n}\n\nimpl U128Div of Div::<u128> {\n    fn div(a: u128, b: u128) -> u128 {\n        let (q, r) = u128_safe_divmod(a, u128_as_non_zero(b));\n        q\n    }\n}\nimpl U128DivEq of DivEq::<u128> {\n    #[inline(always)]\n    fn div_eq(ref self: u128, other: u128) {\n        self = Div::div(self, other);\n    }\n}\n\nimpl U128Rem of Rem::<u128> {\n    fn rem(a: u128, b: u128) -> u128 {\n        let (q, r) = u128_safe_divmod(a, u128_as_non_zero(b));\n        r\n    }\n}\nimpl U128RemEq of RemEq::<u128> {\n    #[inline(always)]\n    fn rem_eq(ref self: u128, other: u128) {\n        self = Rem::rem(self, other);\n    }\n}\n\nextern fn u128_safe_divmod(a: u128, b: NonZero<u128>) -> (u128, u128) implicits(RangeCheck) nopanic;\n\nextern fn u128_lt(a: u128, b: u128) -> bool implicits(RangeCheck) nopanic;\nextern fn u128_eq(a: u128, b: u128) -> bool implicits() nopanic;\nextern fn u128_le(a: u128, b: u128) -> bool implicits(RangeCheck) nopanic;\n\nimpl U128PartialEq of PartialEq::<u128> {\n    #[inline(always)]\n    fn eq(a: u128, b: u128) -> bool {\n        u128_eq(a, b)\n    }\n    #[inline(always)]\n    fn ne(a: u128, b: u128) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U128PartialOrd of PartialOrd::<u128> {\n    #[inline(always)]\n    fn le(a: u128, b: u128) -> bool {\n        u128_le(a, b)\n    }\n    #[inline(always)]\n    fn ge(a: u128, b: u128) -> bool {\n        u128_le(b, a)\n    }\n    #[inline(always)]\n    fn lt(a: u128, b: u128) -> bool {\n        u128_lt(a, b)\n    }\n    #[inline(always)]\n    fn gt(a: u128, b: u128) -> bool {\n        u128_lt(b, a)\n    }\n}\n\nextern type Bitwise;\nextern fn bitwise(a: u128, b: u128) -> (u128, u128, u128) implicits(Bitwise) nopanic;\nimpl U128BitAnd of BitAnd::<u128> {\n    #[inline(always)]\n    fn bitand(a: u128, b: u128) -> u128 {\n        let (v, _, _) = bitwise(a, b);\n        v\n    }\n}\nimpl U128BitXor of BitXor::<u128> {\n    #[inline(always)]\n    fn bitxor(a: u128, b: u128) -> u128 {\n        let (_, v, _) = bitwise(a, b);\n        v\n    }\n}\nimpl U128BitOr of BitOr::<u128> {\n    #[inline(always)]\n    fn bitor(a: u128, b: u128) -> u128 {\n        let (_, _, v) = bitwise(a, b);\n        v\n    }\n}\n\nextern fn u128_is_zero(a: u128) -> IsZeroResult<u128> implicits() nopanic;\n\n#[derive(Copy, Drop)]\nextern type u8;\nextern fn u8_const<value>() -> u8 nopanic;\nextern fn u8_to_felt252(a: u8) -> felt252 nopanic;\n\n#[panic_with('u8_from OF', u8_from_felt252)]\nextern fn u8_try_from_felt252(a: felt252) -> Option<u8> implicits(RangeCheck) nopanic;\n\nextern fn u8_lt(a: u8, b: u8) -> bool implicits(RangeCheck) nopanic;\nextern fn u8_eq(a: u8, b: u8) -> bool implicits() nopanic;\nextern fn u8_le(a: u8, b: u8) -> bool implicits(RangeCheck) nopanic;\n\nimpl U8PartialEq of PartialEq::<u8> {\n    #[inline(always)]\n    fn eq(a: u8, b: u8) -> bool {\n        u8_eq(a, b)\n    }\n    #[inline(always)]\n    fn ne(a: u8, b: u8) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U8PartialOrd of PartialOrd::<u8> {\n    #[inline(always)]\n    fn le(a: u8, b: u8) -> bool {\n        u8_le(a, b)\n    }\n    #[inline(always)]\n    fn ge(a: u8, b: u8) -> bool {\n        u8_le(b, a)\n    }\n    #[inline(always)]\n    fn lt(a: u8, b: u8) -> bool {\n        u8_lt(a, b)\n    }\n    #[inline(always)]\n    fn gt(a: u8, b: u8) -> bool {\n        u8_lt(b, a)\n    }\n}\n\nextern fn u8_overflowing_add(a: u8, b: u8) -> Result<u8, u8> implicits(RangeCheck) nopanic;\nextern fn u8_overflowing_sub(a: u8, b: u8) -> Result<u8, u8> implicits(RangeCheck) nopanic;\n\nfn u8_wrapping_add(a: u8, b: u8) -> u8 implicits(RangeCheck) nopanic {\n    match u8_overflowing_add(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u8_wrapping_sub(a: u8, b: u8) -> u8 implicits(RangeCheck) nopanic {\n    match u8_overflowing_sub(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u8_checked_add(a: u8, b: u8) -> Option<u8> implicits(RangeCheck) nopanic {\n    match u8_overflowing_add(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U8Add of Add::<u8> {\n    fn add(a: u8, b: u8) -> u8 {\n        u8_overflowing_add(a, b).expect('u8_add Overflow')\n    }\n}\nimpl U8AddEq of AddEq::<u8> {\n    #[inline(always)]\n    fn add_eq(ref self: u8, other: u8) {\n        self = Add::add(self, other);\n    }\n}\n\nfn u8_checked_sub(a: u8, b: u8) -> Option<u8> implicits(RangeCheck) nopanic {\n    match u8_overflowing_sub(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U8Sub of Sub::<u8> {\n    fn sub(a: u8, b: u8) -> u8 {\n        u8_overflowing_sub(a, b).expect('u8_sub Overflow')\n    }\n}\nimpl U8SubEq of SubEq::<u8> {\n    #[inline(always)]\n    fn sub_eq(ref self: u8, other: u8) {\n        self = Sub::sub(self, other);\n    }\n}\n\nextern fn u8_wide_mul(a: u8, b: u8) -> u16 implicits() nopanic;\nimpl U8Mul of Mul::<u8> {\n    fn mul(a: u8, b: u8) -> u8 {\n        u8_try_from_felt252(u16_to_felt252(u8_wide_mul(a, b))).expect('u8_mul Overflow')\n    }\n}\nimpl U8MulEq of MulEq::<u8> {\n    #[inline(always)]\n    fn mul_eq(ref self: u8, other: u8) {\n        self = Mul::mul(self, other);\n    }\n}\n\nextern fn u8_is_zero(a: u8) -> IsZeroResult<u8> implicits() nopanic;\nextern fn u8_safe_divmod(a: u8, b: NonZero<u8>) -> (u8, u8) implicits(RangeCheck) nopanic;\n\n#[panic_with('u8 is 0', u8_as_non_zero)]\nfn u8_try_as_non_zero(a: u8) -> Option<NonZero<u8>> implicits() nopanic {\n    match u8_is_zero(a) {\n        IsZeroResult::Zero(()) => Option::None(()),\n        IsZeroResult::NonZero(x) => Option::Some(x),\n    }\n}\n\nimpl U8Div of Div::<u8> {\n    fn div(a: u8, b: u8) -> u8 {\n        let (q, r) = u8_safe_divmod(a, u8_as_non_zero(b));\n        q\n    }\n}\nimpl U8DivEq of DivEq::<u8> {\n    #[inline(always)]\n    fn div_eq(ref self: u8, other: u8) {\n        self = Div::div(self, other);\n    }\n}\n\nimpl U8Rem of Rem::<u8> {\n    fn rem(a: u8, b: u8) -> u8 {\n        let (q, r) = u8_safe_divmod(a, u8_as_non_zero(b));\n        r\n    }\n}\nimpl U8RemEq of RemEq::<u8> {\n    #[inline(always)]\n    fn rem_eq(ref self: u8, other: u8) {\n        self = Rem::rem(self, other);\n    }\n}\n\n#[derive(Copy, Drop)]\nextern type u16;\nextern fn u16_const<value>() -> u16 nopanic;\nextern fn u16_to_felt252(a: u16) -> felt252 nopanic;\n\n#[panic_with('u16_from OF', u16_from_felt252)]\nextern fn u16_try_from_felt252(a: felt252) -> Option<u16> implicits(RangeCheck) nopanic;\n\nextern fn u16_lt(a: u16, b: u16) -> bool implicits(RangeCheck) nopanic;\nextern fn u16_eq(a: u16, b: u16) -> bool implicits() nopanic;\nextern fn u16_le(a: u16, b: u16) -> bool implicits(RangeCheck) nopanic;\n\nimpl U16PartialEq of PartialEq::<u16> {\n    #[inline(always)]\n    fn eq(a: u16, b: u16) -> bool {\n        u16_eq(a, b)\n    }\n    #[inline(always)]\n    fn ne(a: u16, b: u16) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U16PartialOrd of PartialOrd::<u16> {\n    #[inline(always)]\n    fn le(a: u16, b: u16) -> bool {\n        u16_le(a, b)\n    }\n    #[inline(always)]\n    fn ge(a: u16, b: u16) -> bool {\n        u16_le(b, a)\n    }\n    #[inline(always)]\n    fn lt(a: u16, b: u16) -> bool {\n        u16_lt(a, b)\n    }\n    #[inline(always)]\n    fn gt(a: u16, b: u16) -> bool {\n        u16_lt(b, a)\n    }\n}\n\nextern fn u16_overflowing_add(a: u16, b: u16) -> Result<u16, u16> implicits(RangeCheck) nopanic;\nextern fn u16_overflowing_sub(a: u16, b: u16) -> Result<u16, u16> implicits(RangeCheck) nopanic;\n\nfn u16_wrapping_add(a: u16, b: u16) -> u16 implicits(RangeCheck) nopanic {\n    match u16_overflowing_add(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u16_wrapping_sub(a: u16, b: u16) -> u16 implicits(RangeCheck) nopanic {\n    match u16_overflowing_sub(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u16_checked_add(a: u16, b: u16) -> Option<u16> implicits(RangeCheck) nopanic {\n    match u16_overflowing_add(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U16Add of Add::<u16> {\n    fn add(a: u16, b: u16) -> u16 {\n        u16_overflowing_add(a, b).expect('u16_add Overflow')\n    }\n}\nimpl U16AddEq of AddEq::<u16> {\n    #[inline(always)]\n    fn add_eq(ref self: u16, other: u16) {\n        self = Add::add(self, other);\n    }\n}\n\nfn u16_checked_sub(a: u16, b: u16) -> Option<u16> implicits(RangeCheck) nopanic {\n    match u16_overflowing_sub(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U16Sub of Sub::<u16> {\n    fn sub(a: u16, b: u16) -> u16 {\n        u16_overflowing_sub(a, b).expect('u16_sub Overflow')\n    }\n}\nimpl U16SubEq of SubEq::<u16> {\n    #[inline(always)]\n    fn sub_eq(ref self: u16, other: u16) {\n        self = Sub::sub(self, other);\n    }\n}\n\nextern fn u16_wide_mul(a: u16, b: u16) -> u32 implicits() nopanic;\nimpl U16Mul of Mul::<u16> {\n    fn mul(a: u16, b: u16) -> u16 {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        u16_try_from_felt252(u32_to_felt252(u16_wide_mul(a, b))).expect('u16_mul Overflow')\n    }\n}\nimpl U16MulEq of MulEq::<u16> {\n    #[inline(always)]\n    fn mul_eq(ref self: u16, other: u16) {\n        self = Mul::mul(self, other);\n    }\n}\n\nextern fn u16_is_zero(a: u16) -> IsZeroResult<u16> implicits() nopanic;\nextern fn u16_safe_divmod(a: u16, b: NonZero<u16>) -> (u16, u16) implicits(RangeCheck) nopanic;\n\n#[panic_with('u16 is 0', u16_as_non_zero)]\nfn u16_try_as_non_zero(a: u16) -> Option<NonZero<u16>> implicits() nopanic {\n    match u16_is_zero(a) {\n        IsZeroResult::Zero(()) => Option::None(()),\n        IsZeroResult::NonZero(x) => Option::Some(x),\n    }\n}\n\nimpl U16Div of Div::<u16> {\n    fn div(a: u16, b: u16) -> u16 {\n        let (q, r) = u16_safe_divmod(a, u16_as_non_zero(b));\n        q\n    }\n}\nimpl U16DivEq of DivEq::<u16> {\n    #[inline(always)]\n    fn div_eq(ref self: u16, other: u16) {\n        self = Div::div(self, other);\n    }\n}\n\nimpl U16Rem of Rem::<u16> {\n    fn rem(a: u16, b: u16) -> u16 {\n        let (q, r) = u16_safe_divmod(a, u16_as_non_zero(b));\n        r\n    }\n}\nimpl U16RemEq of RemEq::<u16> {\n    #[inline(always)]\n    fn rem_eq(ref self: u16, other: u16) {\n        self = Rem::rem(self, other);\n    }\n}\n\n#[derive(Copy, Drop)]\nextern type u32;\nextern fn u32_const<value>() -> u32 nopanic;\nextern fn u32_to_felt252(a: u32) -> felt252 nopanic;\n\n#[panic_with('u32_from OF', u32_from_felt252)]\nextern fn u32_try_from_felt252(a: felt252) -> Option<u32> implicits(RangeCheck) nopanic;\n\nextern fn u32_lt(a: u32, b: u32) -> bool implicits(RangeCheck) nopanic;\nextern fn u32_eq(a: u32, b: u32) -> bool implicits() nopanic;\nextern fn u32_le(a: u32, b: u32) -> bool implicits(RangeCheck) nopanic;\n\nimpl U32PartialEq of PartialEq::<u32> {\n    #[inline(always)]\n    fn eq(a: u32, b: u32) -> bool {\n        u32_eq(a, b)\n    }\n    #[inline(always)]\n    fn ne(a: u32, b: u32) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U32PartialOrd of PartialOrd::<u32> {\n    #[inline(always)]\n    fn le(a: u32, b: u32) -> bool {\n        u32_le(a, b)\n    }\n    #[inline(always)]\n    fn ge(a: u32, b: u32) -> bool {\n        u32_le(b, a)\n    }\n    #[inline(always)]\n    fn lt(a: u32, b: u32) -> bool {\n        u32_lt(a, b)\n    }\n    #[inline(always)]\n    fn gt(a: u32, b: u32) -> bool {\n        u32_lt(b, a)\n    }\n}\n\nextern fn u32_overflowing_add(a: u32, b: u32) -> Result<u32, u32> implicits(RangeCheck) nopanic;\nextern fn u32_overflowing_sub(a: u32, b: u32) -> Result<u32, u32> implicits(RangeCheck) nopanic;\n\nfn u32_wrapping_add(a: u32, b: u32) -> u32 implicits(RangeCheck) nopanic {\n    match u32_overflowing_add(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u32_wrapping_sub(a: u32, b: u32) -> u32 implicits(RangeCheck) nopanic {\n    match u32_overflowing_sub(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u32_checked_add(a: u32, b: u32) -> Option<u32> implicits(RangeCheck) nopanic {\n    match u32_overflowing_add(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U32Add of Add::<u32> {\n    fn add(a: u32, b: u32) -> u32 {\n        u32_overflowing_add(a, b).expect('u32_add Overflow')\n    }\n}\nimpl U32AddEq of AddEq::<u32> {\n    #[inline(always)]\n    fn add_eq(ref self: u32, other: u32) {\n        self = Add::add(self, other);\n    }\n}\n\nfn u32_checked_sub(a: u32, b: u32) -> Option<u32> implicits(RangeCheck) nopanic {\n    match u32_overflowing_sub(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U32Sub of Sub::<u32> {\n    fn sub(a: u32, b: u32) -> u32 {\n        u32_overflowing_sub(a, b).expect('u32_sub Overflow')\n    }\n}\nimpl U32SubEq of SubEq::<u32> {\n    #[inline(always)]\n    fn sub_eq(ref self: u32, other: u32) {\n        self = Sub::sub(self, other);\n    }\n}\n\nextern fn u32_wide_mul(a: u32, b: u32) -> u64 implicits() nopanic;\nimpl U32Mul of Mul::<u32> {\n    fn mul(a: u32, b: u32) -> u32 {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        u32_try_from_felt252(u64_to_felt252(u32_wide_mul(a, b))).expect('u32_mul Overflow')\n    }\n}\nimpl U32MulEq of MulEq::<u32> {\n    #[inline(always)]\n    fn mul_eq(ref self: u32, other: u32) {\n        self = Mul::mul(self, other);\n    }\n}\n\nextern fn u32_is_zero(a: u32) -> IsZeroResult<u32> implicits() nopanic;\nextern fn u32_safe_divmod(a: u32, b: NonZero<u32>) -> (u32, u32) implicits(RangeCheck) nopanic;\n\n#[panic_with('u32 is 0', u32_as_non_zero)]\nfn u32_try_as_non_zero(a: u32) -> Option<NonZero<u32>> implicits() nopanic {\n    match u32_is_zero(a) {\n        IsZeroResult::Zero(()) => Option::None(()),\n        IsZeroResult::NonZero(x) => Option::Some(x),\n    }\n}\n\nimpl U32Div of Div::<u32> {\n    fn div(a: u32, b: u32) -> u32 {\n        let (q, r) = u32_safe_divmod(a, u32_as_non_zero(b));\n        q\n    }\n}\nimpl U32DivEq of DivEq::<u32> {\n    #[inline(always)]\n    fn div_eq(ref self: u32, other: u32) {\n        self = Div::div(self, other);\n    }\n}\n\nimpl U32Rem of Rem::<u32> {\n    fn rem(a: u32, b: u32) -> u32 {\n        let (q, r) = u32_safe_divmod(a, u32_as_non_zero(b));\n        r\n    }\n}\nimpl U32RemEq of RemEq::<u32> {\n    #[inline(always)]\n    fn rem_eq(ref self: u32, other: u32) {\n        self = Rem::rem(self, other);\n    }\n}\n\n#[derive(Copy, Drop)]\nextern type u64;\nextern fn u64_const<value>() -> u64 nopanic;\nextern fn u64_to_felt252(a: u64) -> felt252 nopanic;\n\n#[panic_with('u64_from OF', u64_from_felt252)]\nextern fn u64_try_from_felt252(a: felt252) -> Option<u64> implicits(RangeCheck) nopanic;\n\nextern fn u64_lt(a: u64, b: u64) -> bool implicits(RangeCheck) nopanic;\nextern fn u64_eq(a: u64, b: u64) -> bool implicits() nopanic;\nextern fn u64_le(a: u64, b: u64) -> bool implicits(RangeCheck) nopanic;\n\nimpl U64PartialEq of PartialEq::<u64> {\n    #[inline(always)]\n    fn eq(a: u64, b: u64) -> bool {\n        u64_eq(a, b)\n    }\n    #[inline(always)]\n    fn ne(a: u64, b: u64) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U64PartialOrd of PartialOrd::<u64> {\n    #[inline(always)]\n    fn le(a: u64, b: u64) -> bool {\n        u64_le(a, b)\n    }\n    #[inline(always)]\n    fn ge(a: u64, b: u64) -> bool {\n        u64_le(b, a)\n    }\n    #[inline(always)]\n    fn lt(a: u64, b: u64) -> bool {\n        u64_lt(a, b)\n    }\n    #[inline(always)]\n    fn gt(a: u64, b: u64) -> bool {\n        u64_lt(b, a)\n    }\n}\n\nextern fn u64_overflowing_add(a: u64, b: u64) -> Result<u64, u64> implicits(RangeCheck) nopanic;\nextern fn u64_overflowing_sub(a: u64, b: u64) -> Result<u64, u64> implicits(RangeCheck) nopanic;\n\nfn u64_wrapping_add(a: u64, b: u64) -> u64 implicits(RangeCheck) nopanic {\n    match u64_overflowing_add(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u64_wrapping_sub(a: u64, b: u64) -> u64 implicits(RangeCheck) nopanic {\n    match u64_overflowing_sub(a, b) {\n        Result::Ok(x) => x,\n        Result::Err(x) => x,\n    }\n}\n\nfn u64_checked_add(a: u64, b: u64) -> Option<u64> implicits(RangeCheck) nopanic {\n    match u64_overflowing_add(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U64Add of Add::<u64> {\n    fn add(a: u64, b: u64) -> u64 {\n        u64_overflowing_add(a, b).expect('u64_add Overflow')\n    }\n}\nimpl U64AddEq of AddEq::<u64> {\n    #[inline(always)]\n    fn add_eq(ref self: u64, other: u64) {\n        self = Add::add(self, other);\n    }\n}\n\nfn u64_checked_sub(a: u64, b: u64) -> Option<u64> implicits(RangeCheck) nopanic {\n    match u64_overflowing_sub(a, b) {\n        Result::Ok(r) => Option::Some(r),\n        Result::Err(r) => Option::None(()),\n    }\n}\n\nimpl U64Sub of Sub::<u64> {\n    fn sub(a: u64, b: u64) -> u64 {\n        u64_overflowing_sub(a, b).expect('u64_sub Overflow')\n    }\n}\nimpl U64SubEq of SubEq::<u64> {\n    #[inline(always)]\n    fn sub_eq(ref self: u64, other: u64) {\n        self = Sub::sub(self, other);\n    }\n}\n\nextern fn u64_wide_mul(a: u64, b: u64) -> u128 implicits() nopanic;\nimpl U64Mul of Mul::<u64> {\n    fn mul(a: u64, b: u64) -> u64 {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        u64_try_from_felt252(u128_to_felt252(u64_wide_mul(a, b))).expect('u64_mul Overflow')\n    }\n}\nimpl U64MulEq of MulEq::<u64> {\n    #[inline(always)]\n    fn mul_eq(ref self: u64, other: u64) {\n        self = Mul::mul(self, other);\n    }\n}\n\nextern fn u64_is_zero(a: u64) -> IsZeroResult<u64> implicits() nopanic;\nextern fn u64_safe_divmod(a: u64, b: NonZero<u64>) -> (u64, u64) implicits(RangeCheck) nopanic;\n\n#[panic_with('u64 is 0', u64_as_non_zero)]\nfn u64_try_as_non_zero(a: u64) -> Option<NonZero<u64>> implicits() nopanic {\n    match u64_is_zero(a) {\n        IsZeroResult::Zero(()) => Option::None(()),\n        IsZeroResult::NonZero(x) => Option::Some(x),\n    }\n}\n\nimpl U64Div of Div::<u64> {\n    fn div(a: u64, b: u64) -> u64 {\n        let (q, r) = u64_safe_divmod(a, u64_as_non_zero(b));\n        q\n    }\n}\nimpl U64DivEq of DivEq::<u64> {\n    #[inline(always)]\n    fn div_eq(ref self: u64, other: u64) {\n        self = Div::div(self, other);\n    }\n}\n\nimpl U64Rem of Rem::<u64> {\n    fn rem(a: u64, b: u64) -> u64 {\n        let (q, r) = u64_safe_divmod(a, u64_as_non_zero(b));\n        r\n    }\n}\nimpl U64RemEq of RemEq::<u64> {\n    #[inline(always)]\n    fn rem_eq(ref self: u64, other: u64) {\n        self = Rem::rem(self, other);\n    }\n}\n\n#[derive(Copy, Drop)]\nstruct u256 {\n    low: u128,\n    high: u128,\n}\n\nfn u256_overflowing_add(a: u256, b: u256) -> (u256, bool) implicits(RangeCheck) nopanic {\n    let (high, overflow) = match u128_overflowing_add(a.high, b.high) {\n        Result::Ok(high) => (high, false),\n        Result::Err(high) => (high, true),\n    };\n    match u128_overflowing_add(a.low, b.low) {\n        Result::Ok(low) => (u256 { low, high }, overflow),\n        Result::Err(low) => {\n            match u128_overflowing_add(high, 1_u128) {\n                Result::Ok(high) => (u256 { low, high }, overflow),\n                Result::Err(high) => (u256 { low, high }, true),\n            }\n        },\n    }\n}\n\nfn u256_overflow_sub(a: u256, b: u256) -> (u256, bool) implicits(RangeCheck) nopanic {\n    let (high, overflow) = match u128_overflowing_sub(a.high, b.high) {\n        Result::Ok(high) => (high, false),\n        Result::Err(high) => (high, true),\n    };\n    match u128_overflowing_sub(a.low, b.low) {\n        Result::Ok(low) => (u256 { low, high }, overflow),\n        Result::Err(low) => {\n            match u128_overflowing_sub(high, 1_u128) {\n                Result::Ok(high) => (u256 { low, high }, overflow),\n                Result::Err(high) => (u256 { low, high }, true),\n            }\n        },\n    }\n}\n\nfn u256_overflow_mul(a: u256, b: u256) -> (u256, bool) {\n    let (high1, low) = u128_wide_mul(a.low, b.low);\n    let (overflow_value1, high2) = u128_wide_mul(a.low, b.high);\n    let (overflow_value2, high3) = u128_wide_mul(a.high, b.low);\n    let (high, overflow) = match u128_overflowing_add(high1, high2) {\n        Result::Ok(high) => (\n            high,\n            overflow_value1 != 0_u128 | overflow_value2 != 0_u128 | (a.high > 0_u128 & b.high > 0_u128)\n        ),\n        Result::Err(high) => (high, true),\n    };\n    let (high, overflow) = match u128_overflowing_add(high, high3) {\n        Result::Ok(high) => (high, overflow),\n        Result::Err(high) => (high, true),\n    };\n    (u256 { low, high }, overflow)\n}\n\nfn u256_checked_add(a: u256, b: u256) -> Option<u256> implicits(RangeCheck) nopanic {\n    let (r, overflow) = u256_overflowing_add(a, b);\n    if overflow {\n        Option::None(())\n    } else {\n        Option::Some(r)\n    }\n}\n\nimpl U256Add of Add::<u256> {\n    fn add(a: u256, b: u256) -> u256 {\n        u256_checked_add(a, b).expect('u256_add Overflow')\n    }\n}\nimpl U256AddEq of AddEq::<u256> {\n    #[inline(always)]\n    fn add_eq(ref self: u256, other: u256) {\n        self = Add::add(self, other);\n    }\n}\n\n#[panic_with('u256_sub OF', u256_sub)]\nfn u256_checked_sub(a: u256, b: u256) -> Option<u256> implicits(RangeCheck) nopanic {\n    let (r, overflow) = u256_overflow_sub(a, b);\n    if overflow {\n        Option::None(())\n    } else {\n        Option::Some(r)\n    }\n}\n\nimpl U256Sub of Sub::<u256> {\n    fn sub(a: u256, b: u256) -> u256 {\n        u256_checked_sub(a, b).expect('u256_sub Overflow')\n    }\n}\nimpl U256SubEq of SubEq::<u256> {\n    #[inline(always)]\n    fn sub_eq(ref self: u256, other: u256) {\n        self = Sub::sub(self, other);\n    }\n}\n\nfn u256_checked_mul(a: u256, b: u256) -> Option<u256> implicits(RangeCheck) {\n    let (r, overflow) = u256_overflow_mul(a, b);\n    if overflow {\n        Option::None(())\n    } else {\n        Option::Some(r)\n    }\n}\n\nimpl U256Mul of Mul::<u256> {\n    fn mul(a: u256, b: u256) -> u256 {\n        u256_checked_mul(a, b).expect('u256_mul Overflow')\n    }\n}\nimpl U256MulEq of MulEq::<u256> {\n    #[inline(always)]\n    fn mul_eq(ref self: u256, other: u256) {\n        self = Mul::mul(self, other);\n    }\n}\n\nimpl U256PartialEq of PartialEq::<u256> {\n    #[inline(always)]\n    fn eq(a: u256, b: u256) -> bool {\n        a.low == b.low & a.high == b.high\n    }\n    #[inline(always)]\n    fn ne(a: u256, b: u256) -> bool {\n        !(a == b)\n    }\n}\n\nimpl U256PartialOrd of PartialOrd::<u256> {\n    #[inline(always)]\n    fn le(a: u256, b: u256) -> bool {\n        !(b < a)\n    }\n    #[inline(always)]\n    fn ge(a: u256, b: u256) -> bool {\n        !(a < b)\n    }\n    fn lt(a: u256, b: u256) -> bool {\n        if a.high < b.high {\n            true\n        } else if a.high == b.high {\n            a.low < b.low\n        } else {\n            false\n        }\n    }\n    #[inline(always)]\n    fn gt(a: u256, b: u256) -> bool {\n        b < a\n    }\n}\n\nimpl U256BitAnd of BitAnd::<u256> {\n    #[inline(always)]\n    fn bitand(a: u256, b: u256) -> u256 {\n        u256 { low: a.low & b.low, high: a.high & b.high }\n    }\n}\nimpl U256BitXor of BitXor::<u256> {\n    #[inline(always)]\n    fn bitxor(a: u256, b: u256) -> u256 {\n        u256 { low: a.low ^ b.low, high: a.high ^ b.high }\n    }\n}\nimpl U256BitOr of BitOr::<u256> {\n    #[inline(always)]\n    fn bitor(a: u256, b: u256) -> u256 {\n        u256 { low: a.low | b.low, high: a.high | b.high }\n    }\n}\n\nfn u256_from_felt252(a: felt252) -> u256 implicits(RangeCheck) nopanic {\n    match u128s_from_felt252(a) {\n        U128sFromFelt252Result::Narrow(low) => u256 { low, high: 0_u128 },\n        U128sFromFelt252Result::Wide((high, low)) => u256 { low, high },\n    }\n}\n\n/// Conversions.\nimpl Felt252TryIntoU8 of TryInto::<felt252, u8> {\n    fn try_into(self: felt252) -> Option<u8> {\n        u8_try_from_felt252(self)\n    }\n}\nimpl U8IntoFelt252 of Into::<u8, felt252> {\n    fn into(self: u8) -> felt252 {\n        u8_to_felt252(self)\n    }\n}\nimpl Felt252TryIntoU16 of TryInto::<felt252, u16> {\n    fn try_into(self: felt252) -> Option<u16> {\n        u16_try_from_felt252(self)\n    }\n}\nimpl U16IntoFelt252 of Into::<u16, felt252> {\n    fn into(self: u16) -> felt252 {\n        u16_to_felt252(self)\n    }\n}\nimpl Felt252TryIntoU32 of TryInto::<felt252, u32> {\n    fn try_into(self: felt252) -> Option<u32> {\n        u32_try_from_felt252(self)\n    }\n}\nimpl U32IntoFelt252 of Into::<u32, felt252> {\n    fn into(self: u32) -> felt252 {\n        u32_to_felt252(self)\n    }\n}\nimpl Felt252TryIntoU64 of TryInto::<felt252, u64> {\n    fn try_into(self: felt252) -> Option<u64> {\n        u64_try_from_felt252(self)\n    }\n}\nimpl U64IntoFelt252 of Into::<u64, felt252> {\n    fn into(self: u64) -> felt252 {\n        u64_to_felt252(self)\n    }\n}\nimpl Felt252TryIntoU128 of TryInto::<felt252, u128> {\n    fn try_into(self: felt252) -> Option<u128> {\n        u128_try_from_felt252(self)\n    }\n}\nimpl U128IntoFelt252 of Into::<u128, felt252> {\n    fn into(self: u128) -> felt252 {\n        u128_to_felt252(self)\n    }\n}\nimpl Felt252IntoU256 of Into::<felt252, u256> {\n    fn into(self: felt252) -> u256 {\n        u256_from_felt252(self)\n    }\n}\nimpl U16TryIntoU8 of TryInto::<u16, u8> {\n    fn try_into(self: u16) -> Option<u8> {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        let as_felt252: felt252 = self.into();\n        as_felt252.try_into()\n    }\n}\nimpl U32TryIntoU16 of TryInto::<u32, u16> {\n    fn try_into(self: u32) -> Option<u16> {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        let as_felt: felt252 = self.into();\n        as_felt.try_into()\n    }\n}\nimpl U64TryIntoU32 of TryInto::<u64, u32> {\n    fn try_into(self: u64) -> Option<u32> {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        let as_felt: felt252 = self.into();\n        as_felt.try_into()\n    }\n}\nimpl U128TryIntoU64 of TryInto::<u128, u64> {\n    fn try_into(self: u128) -> Option<u64> {\n        // TODO(orizi): Use direct conversion, instead of going through felt252.\n        let as_felt: felt252 = self.into();\n        as_felt.try_into()\n    }\n}\n\n// TODO(lior): Restrict the function (using traits) in the high-level compiler so that wrong types\n//   will not lead to Sierra errors.\nextern fn upcast<FromType, ToType>(x: FromType) -> ToType nopanic;\n\n// TODO(lior): Restrict the function (using traits) in the high-level compiler so that wrong types\n//   will not lead to Sierra errors.\nextern fn downcast<FromType, ToType>(x: FromType) -> Option::<ToType> implicits(RangeCheck) nopanic;\n",
    "metadata": {
      "name": "integer.cairo"
    }
  },
  {
    "pageContent": "extern fn revoke_ap_tracking() implicits() nopanic;\n",
    "metadata": {
      "name": "internal.cairo"
    }
  },
  {
    "pageContent": "mod traits;\nuse traits::Add;\nuse traits::AddEq;\nuse traits::BitAnd;\nuse traits::BitOr;\nuse traits::BitXor;\nuse traits::Copy;\nuse traits::Div;\nuse traits::DivEq;\nuse traits::Drop;\nuse traits::Mul;\nuse traits::MulEq;\nuse traits::PartialEq;\nuse traits::PartialOrd;\nuse traits::Rem;\nuse traits::RemEq;\nuse traits::Sub;\nuse traits::SubEq;\nuse traits::Not;\nuse traits::Neg;\nuse traits::Into;\nuse traits::TryInto;\nuse traits::Destruct;\n\n#[derive(Copy, Drop)]\nenum bool {\n    False: (),\n    True: (),\n}\n\nextern fn bool_and_impl(a: bool, b: bool) -> (bool, ) implicits() nopanic;\nimpl BoolBitAnd of BitAnd::<bool> {\n    #[inline(always)]\n    fn bitand(a: bool, b: bool) -> bool {\n        let (r, ) = bool_and_impl(a, b);\n        r\n    }\n}\n\nextern fn bool_or_impl(a: bool, b: bool) -> (bool, ) implicits() nopanic;\nimpl BoolBitOr of BitOr::<bool> {\n    #[inline(always)]\n    fn bitor(a: bool, b: bool) -> bool {\n        let (r, ) = bool_or_impl(a, b);\n        r\n    }\n}\n\nextern fn bool_not_impl(a: bool) -> (bool, ) implicits() nopanic;\n#[inline(always)]\nimpl BoolNot of Not::<bool> {\n    #[inline(always)]\n    fn not(a: bool) -> bool implicits() nopanic {\n        let (r, ) = bool_not_impl(a);\n        r\n    }\n}\n\nextern fn bool_xor_impl(a: bool, b: bool) -> (bool, ) implicits() nopanic;\nimpl BoolBitXor of BitXor::<bool> {\n    #[inline(always)]\n    fn bitxor(a: bool, b: bool) -> bool {\n        let (r, ) = bool_xor_impl(a, b);\n        r\n    }\n}\n\nimpl BoolPartialEq of PartialEq::<bool> {\n    #[inline(always)]\n    fn eq(a: bool, b: bool) -> bool {\n        bool_to_felt252(a) == bool_to_felt252(b)\n    }\n    #[inline(always)]\n    fn ne(a: bool, b: bool) -> bool {\n        !(a == b)\n    }\n}\n\nextern fn bool_to_felt252(a: bool) -> felt252 implicits() nopanic;\n\n// General purpose implicits.\nextern type RangeCheck;\nextern type SegmentArena;\n\n// felt252.\n#[derive(Copy, Drop)]\nextern type felt252;\nextern fn felt252_const<const value>() -> felt252 nopanic;\n\nimpl Felt252Add of Add::<felt252> {\n    #[inline(always)]\n    fn add(a: felt252, b: felt252) -> felt252 {\n        felt252_add(a, b)\n    }\n}\nimpl Felt252AddEq of AddEq::<felt252> {\n    #[inline(always)]\n    fn add_eq(ref self: felt252, other: felt252) {\n        self = Add::add(self, other);\n    }\n}\n\nextern fn felt252_add(a: felt252, b: felt252) -> felt252 nopanic;\nimpl Felt252Sub of Sub::<felt252> {\n    #[inline(always)]\n    fn sub(a: felt252, b: felt252) -> felt252 {\n        felt252_sub(a, b)\n    }\n}\nimpl Felt252SubEq of SubEq::<felt252> {\n    #[inline(always)]\n    fn sub_eq(ref self: felt252, other: felt252) {\n        self = Sub::sub(self, other);\n    }\n}\n\nextern fn felt252_sub(a: felt252, b: felt252) -> felt252 nopanic;\nimpl Felt252Mul of Mul::<felt252> {\n    #[inline(always)]\n    fn mul(a: felt252, b: felt252) -> felt252 {\n        felt252_mul(a, b)\n    }\n}\nimpl Felt252MulEq of MulEq::<felt252> {\n    #[inline(always)]\n    fn mul_eq(ref self: felt252, other: felt252) {\n        self = Mul::mul(self, other);\n    }\n}\n\nextern fn felt252_mul(a: felt252, b: felt252) -> felt252 nopanic;\n\nimpl Felt252Neg of Neg::<felt252> {\n    #[inline(always)]\n    fn neg(a: felt252) -> felt252 {\n        a * felt252_const::<-1>()\n    }\n}\n\nextern type NonZero<T>;\nimpl NonZeroTCopy<T, impl TCopy: Copy::<T>> of Copy::<NonZero::<T>>;\nimpl NonZeroTDrop<T, impl TDrop: Drop::<T>> of Drop::<NonZero::<T>>;\nenum IsZeroResult<T> {\n    Zero: (),\n    NonZero: NonZero<T>,\n}\nextern fn unwrap_non_zero<T>(a: NonZero<T>) -> T nopanic;\n\nimpl IsZeroResultIntoBool<T, impl TDrop: Drop::<T>> of Into::<IsZeroResult<T>, bool> {\n    fn into(self: IsZeroResult<T>) -> bool {\n        match self {\n            IsZeroResult::Zero(()) => true,\n            IsZeroResult::NonZero(_) => false,\n        }\n    }\n}\n\nextern fn felt252_div(a: felt252, b: NonZero<felt252>) -> felt252 nopanic;\n\nimpl Felt252PartialEq of PartialEq::<felt252> {\n    #[inline(always)]\n    fn eq(a: felt252, b: felt252) -> bool {\n        match a - b {\n            0 => bool::True(()),\n            _ => bool::False(()),\n        }\n    }\n    #[inline(always)]\n    fn ne(a: felt252, b: felt252) -> bool {\n        !(a == b)\n    }\n}\n\nextern fn felt252_is_zero(a: felt252) -> IsZeroResult<felt252> nopanic;\n\n// TODO(spapini): Constraint using Copy and Drop traits.\nextern fn dup<T>(obj: T) -> (T, T) nopanic;\nextern fn drop<T>(obj: T) nopanic;\n\n// Boxes.\nmod box;\nuse box::Box;\nuse box::BoxTrait;\n\n// Nullable\nmod nullable;\nuse nullable::FromNullableResult;\nuse nullable::Nullable;\nuse nullable::match_nullable;\nuse nullable::null;\nuse nullable::nullable_from_box;\n\n// Arrays.\nmod array;\nuse array::Array;\nuse array::ArrayTrait;\nuse array::ArrayImpl;\ntype usize = u32;\n\n// Span.\nuse array::Span;\n\n\n// Dictionary.\nmod dict;\nuse dict::Felt252Dict;\nuse dict::SquashedFelt252Dict;\nuse dict::felt252_dict_new;\nuse dict::felt252_dict_write;\nuse dict::felt252_dict_read;\nuse dict::felt252_dict_squash;\nuse dict::Felt252DictTrait;\nuse dict::Felt252DictImpl;\n\n// Result.\nmod result;\nuse result::Result;\n\n// Option.\nmod option;\nuse option::Option;\nuse option::OptionCopy;\nuse option::OptionDrop;\n\n// Clone.\nmod clone;\nuse clone::Clone;\nuse clone::TCopyClone;\n\n// EC.\nmod ec;\nuse ec::EcOp;\nuse ec::EcPoint;\nuse ec::EcPointAdd;\nuse ec::EcPointSub;\nuse ec::EcState;\nuse ec::NonZeroEcPoint;\nuse ec::ec_mul;\nuse ec::ec_neg;\nuse ec::ec_point_from_x;\nuse ec::ec_point_from_x_nz;\nuse ec::ec_point_is_zero;\nuse ec::ec_point_new;\nuse ec::ec_point_new_nz;\nuse ec::ec_point_non_zero;\nuse ec::ec_point_try_new;\nuse ec::ec_point_try_new_nz;\nuse ec::ec_point_unwrap;\nuse ec::ec_point_zero;\nuse ec::ec_state_add_mul;\nuse ec::ec_state_add;\nuse ec::ec_state_finalize;\nuse ec::ec_state_init;\nuse ec::ec_state_try_finalize_nz;\n\nmod ecdsa;\n\n// Integer.\nmod integer;\nuse integer::u128;\nuse integer::u128_const;\nuse integer::u128_sqrt;\nuse integer::U128Add;\nuse integer::U128Sub;\nuse integer::U128Mul;\nuse integer::U128Div;\nuse integer::U128Rem;\nuse integer::U128AddEq;\nuse integer::U128SubEq;\nuse integer::U128MulEq;\nuse integer::U128DivEq;\nuse integer::U128RemEq;\nuse integer::U128PartialOrd;\nuse integer::U128PartialEq;\nuse integer::U128BitAnd;\nuse integer::U128BitOr;\nuse integer::U128BitXor;\nuse integer::u128_is_zero;\nuse integer::u8;\nuse integer::u8_const;\nuse integer::U8Add;\nuse integer::U8Sub;\nuse integer::U8Mul;\nuse integer::U8Div;\nuse integer::U8Rem;\nuse integer::U8AddEq;\nuse integer::U8SubEq;\nuse integer::U8MulEq;\nuse integer::U8DivEq;\nuse integer::U8RemEq;\nuse integer::U8PartialEq;\nuse integer::U8PartialOrd;\nuse integer::u16;\nuse integer::u16_const;\nuse integer::U16Add;\nuse integer::U16Sub;\nuse integer::U16Mul;\nuse integer::U16Div;\nuse integer::U16Rem;\nuse integer::U16AddEq;\nuse integer::U16SubEq;\nuse integer::U16MulEq;\nuse integer::U16DivEq;\nuse integer::U16RemEq;\nuse integer::U16PartialEq;\nuse integer::U16PartialOrd;\nuse integer::u32;\nuse integer::u32_const;\nuse integer::U32Add;\nuse integer::U32Sub;\nuse integer::U32Mul;\nuse integer::U32Div;\nuse integer::U32Rem;\nuse integer::U32AddEq;\nuse integer::U32SubEq;\nuse integer::U32MulEq;\nuse integer::U32DivEq;\nuse integer::U32RemEq;\nuse integer::U32PartialEq;\nuse integer::U32PartialOrd;\nuse integer::u64;\nuse integer::u64_const;\nuse integer::U64Add;\nuse integer::U64Sub;\nuse integer::U64Mul;\nuse integer::U64Div;\nuse integer::U64Rem;\nuse integer::U64AddEq;\nuse integer::U64SubEq;\nuse integer::U64MulEq;\nuse integer::U64DivEq;\nuse integer::U64RemEq;\nuse integer::U64PartialEq;\nuse integer::U64PartialOrd;\nuse integer::u256;\nuse integer::U256Add;\nuse integer::U256Sub;\nuse integer::U256Mul;\nuse integer::U256AddEq;\nuse integer::U256SubEq;\nuse integer::U256MulEq;\nuse integer::U256PartialOrd;\nuse integer::U256PartialEq;\nuse integer::U256BitAnd;\nuse integer::U256BitOr;\nuse integer::U256BitXor;\nuse integer::Felt252TryIntoU8;\nuse integer::U8IntoFelt252;\nuse integer::Felt252TryIntoU16;\nuse integer::U16IntoFelt252;\nuse integer::Felt252TryIntoU32;\nuse integer::U32IntoFelt252;\nuse integer::Felt252TryIntoU64;\nuse integer::U64IntoFelt252;\nuse integer::Felt252TryIntoU128;\nuse integer::U128IntoFelt252;\nuse integer::U16TryIntoU8;\nuse integer::U32TryIntoU16;\nuse integer::U64TryIntoU32;\nuse integer::U128TryIntoU64;\nuse integer::Felt252IntoU256;\nuse integer::Bitwise;\n\n// Gas.\nmod gas;\nuse gas::BuiltinCosts;\nuse gas::GasBuiltin;\nuse gas::get_builtin_costs;\n\n\n// Panics.\nenum PanicResult<T> {\n    Ok: T,\n    Err: Array<felt252>,\n}\nenum never {}\nextern fn panic(data: Array<felt252>) -> never;\n\nfn assert(cond: bool, err_code: felt252) {\n    if !cond {\n        let mut data = ArrayTrait::new();\n        data.append(err_code);\n        panic(data);\n    }\n}\n\n// Serialization and Deserialization.\nmod serde;\n\n// Hash functions.\nmod hash;\nuse hash::pedersen;\nuse hash::Pedersen;\n\n// Debug.\nmod debug;\n\n// Starknet\nmod starknet;\nuse starknet::System;\n\n// Internals.\nmod internal;\n\nmod zeroable;\nuse zeroable::Zeroable;\n\n#[cfg(test)]\nmod test;\n\n// Module for testing only.\nmod testing;\n\n// Tuple Copy and Drop impls.\nimpl TupleSize0Copy of Copy::<()>;\nimpl TupleSize0Drop of Drop::<()>;\n\nimpl TupleSize1Copy<E0, impl E0Copy: Copy::<E0>> of Copy::<(E0, )>;\nimpl TupleSize1Drop<E0, impl E0Drop: Drop::<E0>> of Drop::<(E0, )>;\n\nimpl TupleSize2Copy<E0, E1, impl E0Copy: Copy::<E0>, impl E1Copy: Copy::<E1>> of Copy::<(E0, E1)>;\nimpl TupleSize2Drop<E0, E1, impl E0Drop: Drop::<E0>, impl E1Drop: Drop::<E1>> of Drop::<(E0, E1)>;\n\nimpl TupleSize3Copy<E0,\nE1,\nE2,\nimpl E0Copy: Copy::<E0>,\nimpl E1Copy: Copy::<E1>,\nimpl E2Copy: Copy::<E2>> of Copy::<(E0, E1, E2)>;\nimpl TupleSize3Drop<E0,\nE1,\nE2,\nimpl E0Drop: Drop::<E0>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Drop: Drop::<E2>> of Drop::<(E0, E1, E2)>;\n\nimpl TupleSize4Copy<E0,\nE1,\nE2,\nE3,\nimpl E0Copy: Copy::<E0>,\nimpl E1Copy: Copy::<E1>,\nimpl E2Copy: Copy::<E2>,\nimpl E3Copy: Copy::<E3>> of Copy::<(E0, E1, E2, E3)>;\nimpl TupleSize4Drop<E0,\nE1,\nE2,\nE3,\nimpl E0Drop: Drop::<E0>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Drop: Drop::<E2>,\nimpl E2Drop: Drop::<E3>> of Drop::<(E0, E1, E2, E3)>;\n",
    "metadata": {
      "name": "lib.cairo"
    }
  },
  {
    "pageContent": "extern type Nullable<T>;\n\nenum FromNullableResult<T> {\n    Null: (),\n    NotNull: Box<T>,\n}\n\nextern fn null<T>() -> Nullable<T> nopanic;\nextern fn nullable_from_box<T>(value: Box<T>) -> Nullable<T> nopanic;\nextern fn match_nullable<T>(value: Nullable<T>) -> FromNullableResult<T> nopanic;\n\n// Impls for generic types\nimpl NullableCopy<T, impl TCopy: Copy::<T>> of Copy::<Nullable<T>>;\nimpl NullableDrop<T, impl TDrop: Drop::<T>> of Drop::<Nullable<T>>;\n",
    "metadata": {
      "name": "nullable.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\nenum Option<T> {\n    Some: T,\n    None: (),\n}\ntrait OptionTrait<T> {\n    /// If `val` is `Option::Some(x)`, returns `x`. Otherwise, panics with `err`.\n    fn expect(self: Option<T>, err: felt252) -> T;\n    /// If `val` is `Option::Some(x)`, returns `x`. Otherwise, panics.\n    fn unwrap(self: Option<T>) -> T;\n    /// Returns `true` if the `Option` is `Option::Some`.\n    fn is_some(self: @Option<T>) -> bool;\n    /// Returns `true` if the `Option` is `Option::None`.\n    fn is_none(self: @Option<T>) -> bool;\n}\nimpl OptionTraitImpl<T> of OptionTrait::<T> {\n    fn expect(self: Option<T>, err: felt252) -> T {\n        match self {\n            Option::Some(x) => x,\n            Option::None(()) => {\n                let mut data = ArrayTrait::new();\n                data.append(err);\n                panic(data)\n            },\n        }\n    }\n    fn unwrap(self: Option<T>) -> T {\n        self.expect('Option::unwrap failed.')\n    }\n    fn is_some(self: @Option<T>) -> bool {\n        match self {\n            Option::Some(_) => true,\n            Option::None(_) => false,\n        }\n    }\n    fn is_none(self: @Option<T>) -> bool {\n        match self {\n            Option::Some(_) => false,\n            Option::None(_) => true,\n        }\n    }\n}\n\n// Impls for generic types.\nimpl OptionCopy<T, impl TCopy: Copy::<T>> of Copy::<Option<T>>;\nimpl OptionDrop<T, impl TDrop: Drop::<T>> of Drop::<Option<T>>;\n",
    "metadata": {
      "name": "option.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nenum Result<T, E> {\n    Ok: T,\n    Err: E,\n}\ntrait ResultTrait<T, E> {\n    /// If `val` is `Result::Ok(x)`, returns `x`. Otherwise, panics with `err`.\n    fn expect<impl EDrop: Drop::<E>>(self: Result<T, E>, err: felt252) -> T;\n    /// If `val` is `Result::Ok(x)`, returns `x`. Otherwise, panics.\n    fn unwrap<impl EDrop: Drop::<E>>(self: Result<T, E>) -> T;\n    /// If `val` is `Result::Err(x)`, returns `x`. Otherwise, panics with `err`.\n    fn expect_err<impl TDrop: Drop::<T>>(self: Result<T, E>, err: felt252) -> E;\n    /// If `val` is `Result::Err(x)`, returns `x`. Otherwise, panics.\n    fn unwrap_err<impl TDrop: Drop::<T>>(self: Result<T, E>) -> E;\n    /// Returns `true` if the `Result` is `Result::Ok`.\n    fn is_ok(self: @Result<T, E>) -> bool;\n    /// Returns `true` if the `Result` is `Result::Err`.\n    fn is_err(self: @Result<T, E>) -> bool;\n}\nimpl ResultTraitImpl<T, E> of ResultTrait::<T, E> {\n    fn expect<impl EDrop: Drop::<E>>(self: Result<T, E>, err: felt252) -> T {\n        match self {\n            Result::Ok(x) => x,\n            Result::Err(_) => {\n                let mut data = ArrayTrait::new();\n                data.append(err);\n                panic(data)\n            },\n        }\n    }\n    fn unwrap<impl EDrop: Drop::<E>>(self: Result<T, E>) -> T {\n        self.expect('Result::unwrap failed.')\n    }\n    fn expect_err<impl TDrop: Drop::<T>>(self: Result<T, E>, err: felt252) -> E {\n        match self {\n            Result::Ok(_) => {\n                let mut data = ArrayTrait::new();\n                data.append(err);\n                panic(data)\n            },\n            Result::Err(x) => x,\n        }\n    }\n    fn unwrap_err<impl TDrop: Drop::<T>>(self: Result<T, E>) -> E {\n        self.expect_err('Result::unwrap_err failed.')\n    }\n    fn is_ok(self: @Result<T, E>) -> bool {\n        match self {\n            Result::Ok(_) => true,\n            Result::Err(_) => false,\n        }\n    }\n    fn is_err(self: @Result<T, E>) -> bool {\n        match self {\n            Result::Ok(_) => false,\n            Result::Err(_) => true,\n        }\n    }\n}\n\n// Impls for generic types.\nimpl ResultCopy<T, E, impl TCopy: Copy::<T>, impl ECopy: Copy::<E>> of Copy::<Result<T, E>>;\nimpl ResultDrop<T, E, impl TDrop: Drop::<T>, impl EDrop: Drop::<E>> of Drop::<Result<T, E>>;\n",
    "metadata": {
      "name": "result.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nuse array::SpanTrait;\nuse traits::Into;\nuse traits::TryInto;\n\ntrait Serde<T> {\n    fn serialize(ref serialized: Array<felt252>, input: T);\n    fn deserialize(ref serialized: Span<felt252>) -> Option<T>;\n}\n\nimpl Felt252Serde of Serde::<felt252> {\n    fn serialize(ref serialized: Array<felt252>, input: felt252) {\n        serialized.append(input);\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<felt252> {\n        Option::Some(*serialized.pop_front()?)\n    }\n}\n\nimpl BoolSerde of Serde::<bool> {\n    fn serialize(ref serialized: Array<felt252>, input: bool) {\n        Serde::<felt252>::serialize(ref serialized, if input {\n            1\n        } else {\n            0\n        });\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<bool> {\n        Option::Some(*serialized.pop_front()? != 0)\n    }\n}\n\nimpl U8Serde of Serde::<u8> {\n    fn serialize(ref serialized: Array<felt252>, input: u8) {\n        Serde::<felt252>::serialize(ref serialized, input.into());\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u8> {\n        Option::Some(((*serialized.pop_front()?).try_into())?)\n    }\n}\n\nimpl U16Serde of Serde::<u16> {\n    fn serialize(ref serialized: Array<felt252>, input: u16) {\n        Serde::<felt252>::serialize(ref serialized, input.into());\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u16> {\n        Option::Some(((*serialized.pop_front()?).try_into())?)\n    }\n}\n\nimpl U32Serde of Serde::<u32> {\n    fn serialize(ref serialized: Array<felt252>, input: u32) {\n        Serde::<felt252>::serialize(ref serialized, input.into());\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u32> {\n        Option::Some(((*serialized.pop_front()?).try_into())?)\n    }\n}\n\nimpl U64Serde of Serde::<u64> {\n    fn serialize(ref serialized: Array<felt252>, input: u64) {\n        Serde::<felt252>::serialize(ref serialized, input.into());\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u64> {\n        Option::Some(((*serialized.pop_front()?).try_into())?)\n    }\n}\n\nimpl U128Serde of Serde::<u128> {\n    fn serialize(ref serialized: Array<felt252>, input: u128) {\n        Serde::<felt252>::serialize(ref serialized, input.into());\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u128> {\n        Option::Some(((*serialized.pop_front()?).try_into())?)\n    }\n}\n\nimpl U256Serde of Serde::<u256> {\n    fn serialize(ref serialized: Array<felt252>, input: u256) {\n        Serde::<u128>::serialize(ref serialized, input.low);\n        Serde::<u128>::serialize(ref serialized, input.high);\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<u256> {\n        Option::Some(\n            u256 {\n                low: Serde::<u128>::deserialize(ref serialized)?,\n                high: Serde::<u128>::deserialize(ref serialized)?,\n            }\n        )\n    }\n}\n\nimpl ArraySerde<T, impl TSerde: Serde::<T>, impl TDrop: Drop::<T>> of Serde::<Array::<T>> {\n    fn serialize(ref serialized: Array<felt252>, mut input: Array<T>) {\n        Serde::<usize>::serialize(ref serialized, input.len());\n        serialize_array_helper(ref serialized, input);\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<Array<T>> {\n        let length = *serialized.pop_front()?;\n        let mut arr = ArrayTrait::new();\n        deserialize_array_helper(ref serialized, arr, length)\n    }\n}\n\nfn serialize_array_helper<T, impl TSerde: Serde::<T>, impl TDrop: Drop::<T>>(\n    ref serialized: Array<felt252>, mut input: Array<T>\n) {\n    // TODO(orizi): Replace with simple call once inlining is supported.\n    match gas::withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('Out of gas');\n            panic(data);\n        },\n    }\n    match input.pop_front() {\n        Option::Some(value) => {\n            TSerde::serialize(ref serialized, value);\n            serialize_array_helper(ref serialized, input);\n        },\n        Option::None(_) => {},\n    }\n}\n\nfn deserialize_array_helper<T, impl TSerde: Serde::<T>, impl TDrop: Drop::<T>>(\n    ref serialized: Span<felt252>, mut curr_output: Array<T>, remaining: felt252\n) -> Option<Array<T>> {\n    // TODO(orizi): Replace with simple call once inlining is supported.\n    match gas::withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('Out of gas');\n            panic(data);\n        },\n    }\n    if remaining == 0 {\n        return Option::Some(curr_output);\n    }\n    curr_output.append(TSerde::deserialize(ref serialized)?);\n    deserialize_array_helper(ref serialized, curr_output, remaining - 1)\n}\n\nimpl TupleSize0Serde of Serde::<()> {\n    fn serialize(ref serialized: Array<felt252>, mut input: ()) {}\n    fn deserialize(ref serialized: Span<felt252>) -> Option<()> {\n        Option::Some(())\n    }\n}\n\nimpl TupleSize1Serde<E0, impl E0Serde: Serde::<E0>> of Serde::<(E0, )> {\n    fn serialize(ref serialized: Array<felt252>, mut input: (E0, )) {\n        let (e0, ) = input;\n        E0Serde::serialize(ref serialized, e0)\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<(E0, )> {\n        Option::Some((E0Serde::deserialize(ref serialized)?, ))\n    }\n}\n\nimpl TupleSize2Serde<E0,\nE1,\nimpl E0Serde: Serde::<E0>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Serde: Serde::<E1>,\nimpl E0Drop: Drop::<E1>> of Serde::<(E0, E1)> {\n    fn serialize(ref serialized: Array<felt252>, mut input: (E0, E1)) {\n        let (e0, e1) = input;\n        E0Serde::serialize(ref serialized, e0);\n        E1Serde::serialize(ref serialized, e1)\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<(E0, E1)> {\n        Option::Some((E0Serde::deserialize(ref serialized)?, E1Serde::deserialize(ref serialized)?))\n    }\n}\n\nimpl TupleSize3Serde<E0,\nE1,\nE2,\nimpl E0Serde: Serde::<E0>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Serde: Serde::<E1>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Serde: Serde::<E2>,\nimpl E2Drop: Drop::<E2>> of Serde::<(E0, E1, E2)> {\n    fn serialize(ref serialized: Array<felt252>, mut input: (E0, E1, E2)) {\n        let (e0, e1, e2) = input;\n        E0Serde::serialize(ref serialized, e0);\n        E1Serde::serialize(ref serialized, e1);\n        E2Serde::serialize(ref serialized, e2)\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<(E0, E1, E2)> {\n        Option::Some(\n            (\n                E0Serde::deserialize(ref serialized)?,\n                E1Serde::deserialize(ref serialized)?,\n                E2Serde::deserialize(ref serialized)?\n            )\n        )\n    }\n}\n\nimpl TupleSize4Serde<E0,\nE1,\nE2,\nE3,\nimpl E0Serde: Serde::<E0>,\nimpl E0Drop: Drop::<E0>,\nimpl E1Serde: Serde::<E1>,\nimpl E1Drop: Drop::<E1>,\nimpl E2Serde: Serde::<E2>,\nimpl E2Drop: Drop::<E2>,\nimpl E3Serde: Serde::<E3>,\nimpl E3Drop: Drop::<E3>> of Serde::<(E0, E1, E2, E3)> {\n    fn serialize(ref serialized: Array<felt252>, mut input: (E0, E1, E2, E3)) {\n        let (e0, e1, e2, e3) = input;\n        E0Serde::serialize(ref serialized, e0);\n        E1Serde::serialize(ref serialized, e1);\n        E2Serde::serialize(ref serialized, e2);\n        E3Serde::serialize(ref serialized, e3)\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<(E0, E1, E2, E3)> {\n        Option::Some(\n            (\n                E0Serde::deserialize(ref serialized)?,\n                E1Serde::deserialize(ref serialized)?,\n                E2Serde::deserialize(ref serialized)?,\n                E3Serde::deserialize(ref serialized)?\n            )\n        )\n    }\n}\n\n",
    "metadata": {
      "name": "serde.cairo"
    }
  },
  {
    "pageContent": "use zeroable::Zeroable;\n\n#[derive(Copy, Drop)]\nextern type ClassHash;\n\n\nextern fn class_hash_const<const address>() -> ClassHash nopanic;\nextern fn class_hash_to_felt252(address: ClassHash) -> felt252 nopanic;\n\nextern fn class_hash_try_from_felt252(\n    address: felt252\n) -> Option<ClassHash> implicits(RangeCheck) nopanic;\n\nimpl Felt252TryIntoClassHash of TryInto::<felt252, ClassHash> {\n    fn try_into(self: felt252) -> Option<ClassHash> {\n        class_hash_try_from_felt252(self)\n    }\n}\nimpl ClassHashIntoFelt252 of Into::<ClassHash, felt252> {\n    fn into(self: ClassHash) -> felt252 {\n        class_hash_to_felt252(self)\n    }\n}\n\nimpl ClassHashZeroable of Zeroable::<ClassHash> {\n    fn zero() -> ClassHash {\n        class_hash_const::<0>()\n    }\n\n    #[inline(always)]\n    fn is_zero(self: ClassHash) -> bool {\n        class_hash_to_felt252(self).is_zero()\n    }\n\n    #[inline(always)]\n    fn is_non_zero(self: ClassHash) -> bool {\n        !self.is_zero()\n    }\n}\n\nimpl ClassHashSerde of serde::Serde::<ClassHash> {\n    fn serialize(ref serialized: Array<felt252>, input: ClassHash) {\n        serde::Serde::serialize(ref serialized, class_hash_to_felt252(input));\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<ClassHash> {\n        Option::Some(class_hash_try_from_felt252(serde::Serde::deserialize(ref serialized)?)?)\n    }\n}\n\nimpl ClassHashPartialEq of PartialEq::<ClassHash> {\n    #[inline(always)]\n    fn eq(a: ClassHash, b: ClassHash) -> bool {\n        class_hash_to_felt252(a) == class_hash_to_felt252(b)\n    }\n    #[inline(always)]\n    fn ne(a: ClassHash, b: ClassHash) -> bool {\n        !(a == b)\n    }\n}\n",
    "metadata": {
      "name": "class_hash.cairo"
    }
  },
  {
    "pageContent": "use zeroable::Zeroable;\n\n#[derive(Copy, Drop)]\nextern type ContractAddress;\n\n\nextern fn contract_address_const<const address>() -> ContractAddress nopanic;\nextern fn contract_address_to_felt252(address: ContractAddress) -> felt252 nopanic;\n\nextern fn contract_address_try_from_felt252(\n    address: felt252\n) -> Option<ContractAddress> implicits(RangeCheck) nopanic;\n\nimpl Felt252TryIntoContractAddress of TryInto::<felt252, ContractAddress> {\n    fn try_into(self: felt252) -> Option<ContractAddress> {\n        contract_address_try_from_felt252(self)\n    }\n}\nimpl ContractAddressIntoFelt252 of Into::<ContractAddress, felt252> {\n    fn into(self: ContractAddress) -> felt252 {\n        contract_address_to_felt252(self)\n    }\n}\n\nimpl ContractAddressZeroable of Zeroable::<ContractAddress> {\n    fn zero() -> ContractAddress {\n        contract_address_const::<0>()\n    }\n\n    #[inline(always)]\n    fn is_zero(self: ContractAddress) -> bool {\n        contract_address_to_felt252(self).is_zero()\n    }\n\n    #[inline(always)]\n    fn is_non_zero(self: ContractAddress) -> bool {\n        !self.is_zero()\n    }\n}\n\nimpl ContractAddressSerde of serde::Serde::<ContractAddress> {\n    fn serialize(ref serialized: Array<felt252>, input: ContractAddress) {\n        serde::Serde::serialize(ref serialized, contract_address_to_felt252(input));\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<ContractAddress> {\n        Option::Some(contract_address_try_from_felt252(serde::Serde::deserialize(ref serialized)?)?)\n    }\n}\n\nimpl ContractAddressPartialEq of PartialEq::<ContractAddress> {\n    #[inline(always)]\n    fn eq(a: ContractAddress, b: ContractAddress) -> bool {\n        contract_address_to_felt252(a) == contract_address_to_felt252(b)\n    }\n    #[inline(always)]\n    fn ne(a: ContractAddress, b: ContractAddress) -> bool {\n        !(a == b)\n    }\n}\n",
    "metadata": {
      "name": "contract_address.cairo"
    }
  },
  {
    "pageContent": "use starknet::SyscallResultTrait;\nuse starknet::SyscallResult;\nuse starknet::syscalls::get_execution_info_syscall;\nuse starknet::contract_address::ContractAddress;\nuse box::BoxTrait;\n\n#[derive(Copy, Drop)]\nstruct ExecutionInfo {\n    block_info: Box<BlockInfo>,\n    tx_info: Box<TxInfo>,\n    caller_address: ContractAddress,\n    contract_address: ContractAddress,\n    entry_point_selector: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct BlockInfo {\n    block_number: u64,\n    block_timestamp: u64,\n    sequencer_address: ContractAddress,\n}\n\n#[derive(Copy, Drop)]\nstruct TxInfo {\n    // The version of the transaction. It is fixed (currently, 1) in the OS, and should be\n    // signed by the account contract.\n    // This field allows invalidating old transactions, whenever the meaning of the other\n    // transaction fields is changed (in the OS).\n    version: felt252,\n    // The account contract from which this transaction originates.\n    account_contract_address: ContractAddress,\n    // The max_fee field of the transaction.\n    max_fee: u128,\n    // The signature of the transaction.\n    signature: Span<felt252>,\n    // The hash of the transaction.\n    transaction_hash: felt252,\n    // The identifier of the chain.\n    // This field can be used to prevent replay of testnet transactions on mainnet.\n    chain_id: felt252,\n    // The transaction's nonce.\n    nonce: felt252,\n}\n\nfn get_execution_info() -> Box<ExecutionInfo> {\n    get_execution_info_syscall().unwrap_syscall()\n}\n\nfn get_caller_address() -> ContractAddress {\n    get_execution_info().unbox().caller_address\n}\n\nfn get_contract_address() -> ContractAddress {\n    get_execution_info().unbox().contract_address\n}\n\nfn get_block_info() -> Box<BlockInfo> {\n    get_execution_info().unbox().block_info\n}\n\nfn get_tx_info() -> Box<TxInfo> {\n    get_execution_info().unbox().tx_info\n}\n",
    "metadata": {
      "name": "info.cairo"
    }
  },
  {
    "pageContent": "use traits::Into;\nuse traits::TryInto;\nuse option::OptionTrait;\nuse starknet::SyscallResult;\nuse starknet::syscalls::storage_read_syscall;\nuse starknet::syscalls::storage_write_syscall;\nuse starknet::contract_address::ContractAddress;\nuse starknet::contract_address::Felt252TryIntoContractAddress;\nuse starknet::contract_address::ContractAddressIntoFelt252;\nuse starknet::class_hash::ClassHash;\nuse starknet::class_hash::Felt252TryIntoClassHash;\nuse starknet::class_hash::ClassHashIntoFelt252;\n\n#[derive(Copy, Drop)]\nextern type StorageAddress;\n\n#[derive(Copy, Drop)]\nextern type StorageBaseAddress;\n\n// Storage.\nextern fn storage_base_address_const<const address>() -> StorageBaseAddress nopanic;\nextern fn storage_base_address_from_felt252(\n    addr: felt252\n) -> StorageBaseAddress implicits(RangeCheck) nopanic;\n\nextern fn storage_address_to_felt252(address: StorageAddress) -> felt252 nopanic;\nextern fn storage_address_from_base_and_offset(\n    base: StorageBaseAddress, offset: u8\n) -> StorageAddress nopanic;\n\nextern fn storage_address_from_base(base: StorageBaseAddress) -> StorageAddress nopanic;\n\nextern fn storage_address_try_from_felt252(\n    address: felt252\n) -> Option<StorageAddress> implicits(RangeCheck) nopanic;\n\nimpl Felt252TryIntoStorageAddress of TryInto::<felt252, StorageAddress> {\n    fn try_into(self: felt252) -> Option<StorageAddress> {\n        storage_address_try_from_felt252(self)\n    }\n}\nimpl StorageAddressIntoFelt252 of Into::<StorageAddress, felt252> {\n    fn into(self: StorageAddress) -> felt252 {\n        storage_address_to_felt252(self)\n    }\n}\n\nimpl StorageAddressSerde of serde::Serde::<StorageAddress> {\n    fn serialize(ref serialized: Array<felt252>, input: StorageAddress) {\n        serde::Serde::serialize(ref serialized, storage_address_to_felt252(input));\n    }\n    fn deserialize(ref serialized: Span<felt252>) -> Option<StorageAddress> {\n        Option::Some(storage_address_try_from_felt252(serde::Serde::deserialize(ref serialized)?)?)\n    }\n}\n\ntrait StorageAccess<T> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<T>;\n    fn write(address_domain: u32, base: StorageBaseAddress, value: T) -> SyscallResult<()>;\n}\n\nimpl StorageAccessFelt252 of StorageAccess::<felt252> {\n    #[inline(always)]\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<felt252> {\n        storage_read_syscall(address_domain, storage_address_from_base(base))\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: felt252) -> SyscallResult<()> {\n        storage_write_syscall(address_domain, storage_address_from_base(base), value)\n    }\n}\n\nimpl StorageAccessBool of StorageAccess::<bool> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<bool> {\n        Result::Ok(StorageAccess::<felt252>::read(address_domain, base)? != 0)\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: bool) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, if value {\n            1\n        } else {\n            0\n        })\n    }\n}\n\nimpl StorageAccessU8 of StorageAccess::<u8> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u8> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('StorageAccessU8 - non u8')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u8) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessU16 of StorageAccess::<u16> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u16> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('StorageAccessU16 - non u16')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u16) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessU32 of StorageAccess::<u32> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u32> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('StorageAccessU32 - non u32')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u32) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessU64 of StorageAccess::<u64> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u64> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('StorageAccessU64 - non u64')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u64) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessU128 of StorageAccess::<u128> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u128> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('StorageAccessU128 - non u128')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u128) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessU256 of StorageAccess::<u256> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<u256> {\n        Result::Ok(\n            u256 {\n                low: StorageAccess::<u128>::read(address_domain, base)?,\n                high: storage_read_syscall(\n                    address_domain, storage_address_from_base_and_offset(base, 1_u8)\n                )?.try_into().expect('StorageAccessU256 - non u256')\n            }\n        )\n    }\n    fn write(address_domain: u32, base: StorageBaseAddress, value: u256) -> SyscallResult<()> {\n        StorageAccess::<u128>::write(address_domain, base, value.low)?;\n        storage_write_syscall(\n            address_domain, storage_address_from_base_and_offset(base, 1_u8), value.high.into()\n        )\n    }\n}\n\nimpl StorageAccessStorageAddress of StorageAccess::<StorageAddress> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<StorageAddress> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('Non StorageAddress')\n        )\n    }\n    #[inline(always)]\n    fn write(\n        address_domain: u32, base: StorageBaseAddress, value: StorageAddress\n    ) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessContractAddress of StorageAccess::<ContractAddress> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<ContractAddress> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(\n                address_domain, base\n            )?.try_into().expect('Non ContractAddress')\n        )\n    }\n    #[inline(always)]\n    fn write(\n        address_domain: u32, base: StorageBaseAddress, value: ContractAddress\n    ) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n\nimpl StorageAccessClassHash of StorageAccess::<ClassHash> {\n    fn read(address_domain: u32, base: StorageBaseAddress) -> SyscallResult<ClassHash> {\n        Result::Ok(\n            StorageAccess::<felt252>::read(address_domain, base)?.try_into().expect('Non ClassHash')\n        )\n    }\n    #[inline(always)]\n    fn write(address_domain: u32, base: StorageBaseAddress, value: ClassHash) -> SyscallResult<()> {\n        StorageAccess::<felt252>::write(address_domain, base, value.into())\n    }\n}\n",
    "metadata": {
      "name": "storage_access.cairo"
    }
  },
  {
    "pageContent": "use starknet::SyscallResult;\nuse starknet::storage_access::StorageAddress;\nuse starknet::class_hash::ClassHash;\nuse starknet::contract_address::ContractAddress;\n\n// Calls a given contract.\n// `address` - The address of the called contract.\n// `entry_point_selector` - A selector for a function within that contract.\n// `calldata` - Call arguments.\nextern fn call_contract_syscall(\n    address: ContractAddress, entry_point_selector: felt252, calldata: Span<felt252>\n) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;\n\n// Deploys a new instance of a previously declared class.\n// `class_hash` - The class hash of the contract to be deployed.\n// `contract_address_salt` - The salt, an arbitrary value provided by the sender, used in the\n//     computation of the contract's address.\n// `calldata` - Call arguments for the constructor.\n// `deploy_from_zero` - Deploy the contract from the zero address.\nextern fn deploy_syscall(\n    class_hash: ClassHash,\n    contract_address_salt: felt252,\n    calldata: Span<felt252>,\n    deploy_from_zero: bool,\n) -> SyscallResult<(ContractAddress, Span::<felt252>)> implicits(GasBuiltin, System) nopanic;\n\n// Emits an event.\n// `keys` - The keys of the event.\n// `data` - The data of the event.\nextern fn emit_event_syscall(\n    keys: Span<felt252>, data: Span<felt252>\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n\n// Gets information about the current execution.\nextern fn get_execution_info_syscall() -> SyscallResult<Box<starknet::info::ExecutionInfo>> implicits(\n    GasBuiltin, System\n) nopanic;\n\n// Calls the requested function in any previously declared class.\n// `class_hash` - The hash of the class you want to use.\n// `function_selector` - A selector for a function within that class.\n// `calldata` - Call arguments.\nextern fn library_call_syscall(\n    class_hash: ClassHash, function_selector: felt252, calldata: Span<felt252>\n) -> SyscallResult<Span<felt252>> implicits(GasBuiltin, System) nopanic;\n\n// TODO(Ilya): Decide if we limit the type of `to_address`.\n// Sends a message to L1.\n// `to_address` - The recipient's L1 address.\n// `payload` - The content of the message.\nextern fn send_message_to_l1_syscall(\n    to_address: felt252, payload: Span<felt252>\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n\n// Gets the value of a key in the storage of the calling contract.\n// `address_domain` - The domain of the address. Only address_domain 0 is currently supported,\n//     in the future it will enable access to address spaces with different data availability\n//     guarantees.\n// `address` - The address of the storage key to read.\nextern fn storage_read_syscall(\n    address_domain: u32, address: StorageAddress, \n) -> SyscallResult<felt252> implicits(GasBuiltin, System) nopanic;\n\n// Sets the value of a key in the storage of the calling contract.\n// `address_domain` - The domain of the address. Only address_domain 0 is currently supported,\n//     in the future it will enable access to address spaces with different data availability\n//     guarantees.\n// `address` - The address of the storage key to write.\n// `value` - The value to write to the key.\nextern fn storage_write_syscall(\n    address_domain: u32, address: StorageAddress, value: felt252\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n\n\n// Replaces the class hash of the current contract.\n// `class_hash` - The class hash that should replace the current one.\nextern fn replace_class_syscall(\n    class_hash: ClassHash\n) -> SyscallResult<()> implicits(GasBuiltin, System) nopanic;\n",
    "metadata": {
      "name": "syscalls.cairo"
    }
  },
  {
    "pageContent": "use starknet::ContractAddress;\n\nextern fn set_caller_address(address: ContractAddress) implicits() nopanic;\nextern fn set_contract_address(address: ContractAddress) implicits() nopanic;\nextern fn set_sequencer_address(address: ContractAddress) implicits() nopanic;\nextern fn set_block_number(block_number: u64) implicits() nopanic;\nextern fn set_block_timestamp(block_timestamp: u64) implicits() nopanic;\n",
    "metadata": {
      "name": "testing.cairo"
    }
  },
  {
    "pageContent": "use box::Box;\nuse option::OptionTrait;\nuse array::Span;\nuse traits::Into;\nuse traits::TryInto;\nuse zeroable::Zeroable;\n\n// Re-imports\n// StorageAccess\nmod storage_access;\nuse storage_access::StorageAccess;\nuse storage_access::StorageAddress;\nuse storage_access::StorageBaseAddress;\nuse storage_access::storage_base_address_const;\nuse storage_access::storage_base_address_from_felt252;\nuse storage_access::storage_address_from_base;\nuse storage_access::storage_address_from_base_and_offset;\nuse storage_access::storage_address_try_from_felt252;\n\n// Module containing all the extern declaration of the syscalls.\nmod syscalls;\nuse syscalls::call_contract_syscall;\nuse syscalls::storage_read_syscall;\nuse syscalls::storage_write_syscall;\n\n// ContractAddress\nmod contract_address;\nuse contract_address::ContractAddress;\nuse contract_address::ContractAddressIntoFelt252;\nuse contract_address::Felt252TryIntoContractAddress;\nuse contract_address::contract_address_const;\nuse contract_address::contract_address_to_felt252;\nuse contract_address::contract_address_try_from_felt252;\nuse contract_address::ContractAddressZeroable;\n\n// ContractAddress\nmod class_hash;\nuse class_hash::ClassHash;\nuse class_hash::ClassHashIntoFelt252;\nuse class_hash::Felt252TryIntoClassHash;\nuse class_hash::class_hash_const;\nuse class_hash::ClassHashZeroable;\n\nmod info;\nuse info::ExecutionInfo;\nuse info::BlockInfo;\nuse info::TxInfo;\nuse info::get_execution_info;\nuse info::get_caller_address;\nuse info::get_contract_address;\nuse info::get_block_info;\nuse info::get_tx_info;\n\nextern type System;\n\n// An Helper function to force the inclusion of `System` in the list of implicits.\nfn use_system_implicit() implicits(System) {}\n\n/// The result type for a syscall.\ntype SyscallResult<T> = Result<T, Array<felt252>>;\n\ntrait SyscallResultTrait<T> {\n    /// If `val` is `Result::Ok(x)`, returns `x`. Otherwise, panics with the revert reason.\n    fn unwrap_syscall(self: SyscallResult<T>) -> T;\n}\nimpl SyscallResultTraitImpl<T> of SyscallResultTrait::<T> {\n    fn unwrap_syscall(self: SyscallResult<T>) -> T {\n        match self {\n            Result::Ok(x) => x,\n            Result::Err(revert_reason) => {\n                panic(revert_reason)\n            },\n        }\n    }\n}\n\n/// The expected return value of the `__validate*__` functions of an accounted contract.\nconst VALIDATED: felt252 = 'VALID';\n\n// Module for starknet testing only.\nmod testing;\n",
    "metadata": {
      "name": "starknet.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nuse array::SpanTrait;\nuse dict::Felt252DictTrait;\nuse option::OptionTrait;\nuse option::OptionTraitImpl;\nuse core::ec;\nuse core::traits::TryInto;\nuse core::traits::Into;\nuse box::BoxTrait;\n\n\n#[test]\n#[should_panic(expected = ('assert(false)', ))]\nfn test_assert_false() {\n    assert(false, 'assert(false)');\n}\n\n#[test]\nfn test_assert_true() {\n    assert(true, 'assert(true)');\n}\n\n#[test]\nfn test_bool_operators() {\n    assert(true == true, 't == t');\n    assert(false == false, 'f == f');\n    assert(!true == false, '!t == f');\n    assert(!false == true, '!f == t');\n    assert(true != false, 't != f');\n    assert(false != true, 'f != t');\n    assert(!(false & false), '!(f & f)');\n    assert(!(true & false), '!(t & f)');\n    assert(!(false & true), '!(f & t)');\n    assert(true & true, 't & t');\n    assert(!(false | false), '!(f | f)');\n    assert(true | false, 't | f');\n    assert(false | true, 'f | t');\n    assert(true | true, 't | t');\n    assert(!(false ^ false), '!(f ^ f)');\n    assert(true ^ false, 't ^ f');\n    assert(false ^ true, 'f ^ t');\n    assert(!(true ^ true), '!(t ^ t)');\n}\n\n#[test]\nfn test_ec_operations() {\n    // Beta + 2 is a square, and for x = 1 and alpha = 1, x^3 + alpha * x + beta = beta + 2.\n    let beta_p2_root = 2487829544412206244690656897973144572467842667075005257202960243805141046681;\n    let p = ec_point_from_x(1).unwrap();\n    let p_nz = ec_point_non_zero(p);\n    let (x, y) = ec_point_unwrap(p_nz);\n    assert(x == 1, 'x != 1');\n    assert(y == beta_p2_root | y == -beta_p2_root, 'y is wrong');\n\n    let mut state = ec_state_init();\n    ec_state_add(ref state, p_nz);\n    let q = ec_state_try_finalize_nz(state).expect('zero point');\n    let (qx, qy) = ec_point_unwrap(q);\n    assert(qx == x, 'bad finalize x');\n    assert(qy == y, 'bad finalize y');\n\n    // Try doing the same thing with the EC op builtin.\n    let mut state = ec_state_init();\n    ec_state_add_mul(ref state, 1, p_nz);\n    let q3 = ec_state_try_finalize_nz(state).expect('zero point');\n    let (qx, qy) = ec_point_unwrap(q3);\n    assert(qx == x, 'bad EC op x');\n    assert(qy == y, 'bad EC op y');\n\n    // Try computing `p + p` using the ec_mul function.\n    let double_p = ec_mul(p, 2);\n    let (double_x, double_y) = ec_point_unwrap(ec_point_non_zero(double_p));\n    let expected_double_y =\n        3572434102142093425782752266058856056057826477682467661647843687948039943621;\n    assert(\n        double_x == 75984168971785666410219869038140038216102669781812169677875295511117260233,\n        'bad double x'\n    );\n    assert(double_y == expected_double_y | double_y == -expected_double_y, 'bad double y');\n\n    // Compute `2p - p`.\n    let (sub_x, sub_y) = ec_point_unwrap(ec_point_non_zero(double_p - p));\n    assert(sub_x == x, 'bad x for 2p - p');\n    assert(sub_y == y, 'bad y for 2p - p');\n\n    // Compute `p - p`.\n    assert(ec_point_is_zero(p - p).into(), 'p - p did not return 0.');\n\n    // Compute `(-p) - p`.\n    let (sub2_x, sub2_y) = ec_point_unwrap(ec_point_non_zero(ec_neg(p) - p));\n    assert(sub2_x == double_x, 'bad x for (-p) - p');\n    assert(sub2_y == -double_y, 'bad y for (-p) - p');\n}\n\n#[test]\n#[should_panic]\nfn test_bad_ec_point_creation() {\n    ec_point_new(0, 0);\n}\n\n#[test]\nfn test_ec_point_finalization_zero() {\n    let state = ec_state_init();\n    let point_at_infinity = ec_state_try_finalize_nz(state);\n    assert(point_at_infinity.is_none(), 'Wrong point');\n}\n\n#[test]\nfn test_ecdsa() {\n    let message_hash = 0x503f4bea29baee10b22a7f10bdc82dda071c977c1f25b8f3973d34e6b03b2c;\n    let public_key = 0x7b7454acbe7845da996377f85eb0892044d75ae95d04d3325a391951f35d2ec;\n    let signature_r = 0xbe96d72eb4f94078192c2e84d5230cde2a70f4b45c8797e2c907acff5060bb;\n    let signature_s = 0x677ae6bba6daf00d2631fab14c8acf24be6579f9d9e98f67aa7f2770e57a1f5;\n    assert(\n        ecdsa::check_ecdsa_signature(:message_hash, :public_key, :signature_r, :signature_s),\n        'ecdsa returned false'\n    );\n    assert(\n        !ecdsa::check_ecdsa_signature(\n            message_hash: message_hash + 1, :public_key, :signature_r, :signature_s\n        ),\n        'ecdsa - wrong message'\n    );\n    assert(\n        !ecdsa::check_ecdsa_signature(\n            :message_hash, public_key: public_key + 1, :signature_r, :signature_s\n        ),\n        'ecdsa - wrong public_key'\n    );\n    assert(\n        !ecdsa::check_ecdsa_signature(\n            :message_hash, :public_key, signature_r: signature_r + 1, :signature_s\n        ),\n        'ecdsa - wrong r'\n    );\n    assert(\n        !ecdsa::check_ecdsa_signature(\n            :message_hash, :public_key, :signature_r, signature_s: signature_s + 1\n        ),\n        'ecdsa - wrong s'\n    );\n}\n\n#[test]\nfn test_ec_mul() {\n    let p = ec_point_new(\n        x: 336742005567258698661916498343089167447076063081786685068305785816009957563,\n        y: 1706004133033694959518200210163451614294041810778629639790706933324248611779,\n    );\n    let m = 2713877091499598330239944961141122840311015265600950719674787125185463975936;\n    let (x, y) = ec_point_unwrap(ec_point_non_zero(ec_mul(p, m)));\n\n    assert(\n        x == 2881632108168892236043523177391659237686965655035240771134509747985978822780,\n        'ec_mul failed (x).'\n    );\n    assert(\n        y == 591135563672138037839394207500885413019058613584891498394077262936524140839,\n        'ec_mul failed (y).'\n    );\n}\n\n#[test]\nfn test_felt252_operators() {\n    assert(1 + 3 == 4, '1 + 3 == 4');\n    assert(3 + 6 == 9, '3 + 6 == 9');\n    assert(3 - 1 == 2, '3 - 1 == 2');\n    assert(1231 - 231 == 1000, '1231-231=1000');\n    assert(1 * 3 == 3, '1 * 3 == 3');\n    assert(3 * 6 == 18, '3 * 6 == 18');\n    assert(-3 == 1 - 4, '-3 == 1 - 4');\n}\n\n#[test]\nfn test_u8_operators() {\n    assert(1_u8 == 1_u8, '1 == 1');\n    assert(1_u8 != 2_u8, '1 != 2');\n    assert(1_u8 + 3_u8 == 4_u8, '1 + 3 == 4');\n    assert(3_u8 + 6_u8 == 9_u8, '3 + 6 == 9');\n    assert(3_u8 - 1_u8 == 2_u8, '3 - 1 == 2');\n    assert(1_u8 * 3_u8 == 3_u8, '1 * 3 == 3');\n    assert(2_u8 * 4_u8 == 8_u8, '2 * 4 == 8');\n    assert(19_u8 / 7_u8 == 2_u8, '19 / 7 == 2');\n    assert(19_u8 % 7_u8 == 5_u8, '19 % 7 == 5');\n    assert(231_u8 - 131_u8 == 100_u8, '231-131=100');\n    assert(1_u8 < 4_u8, '1 < 4');\n    assert(1_u8 <= 4_u8, '1 <= 4');\n    assert(!(4_u8 < 4_u8), '!(4 < 4)');\n    assert(4_u8 <= 4_u8, '4 <= 4');\n    assert(5_u8 > 2_u8, '5 > 2');\n    assert(5_u8 >= 2_u8, '5 >= 2');\n    assert(!(3_u8 > 3_u8), '!(3 > 3)');\n    assert(3_u8 >= 3_u8, '3 >= 3');\n}\n\n#[test]\n#[should_panic]\nfn test_u8_sub_overflow_1() {\n    0_u8 - 1_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_sub_overflow_2() {\n    0_u8 - 3_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_sub_overflow_3() {\n    1_u8 - 3_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_sub_overflow_4() {\n    100_u8 - 250_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_add_overflow_1() {\n    128_u8 + 128_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_add_overflow_2() {\n    200_u8 + 60_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_mul_overflow_1() {\n    0x10_u8 * 0x10_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_mul_overflow_2() {\n    0x11_u8 * 0x10_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_mul_overflow_3() {\n    2_u8 * 0x80_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_div_by_0() {\n    2_u8 / 0_u8;\n}\n\n#[test]\n#[should_panic]\nfn test_u8_mod_by_0() {\n    2_u8 % 0_u8;\n}\n\n#[test]\nfn test_u16_operators() {\n    assert(1_u16 == 1_u16, '1 == 1');\n    assert(1_u16 != 2_u16, '1 != 2');\n    assert(1_u16 + 3_u16 == 4_u16, '1 + 3 == 4');\n    assert(3_u16 + 6_u16 == 9_u16, '3 + 6 == 9');\n    assert(3_u16 - 1_u16 == 2_u16, '3 - 1 == 2');\n    assert(231_u16 - 131_u16 == 100_u16, '231-131=100');\n    assert(1_u16 * 3_u16 == 3_u16, '1 * 3 == 3');\n    assert(2_u16 * 4_u16 == 8_u16, '2 * 4 == 8');\n    assert(51725_u16 / 7_u16 == 7389_u16, '51725 / 7 == 7389');\n    assert(51725_u16 % 7_u16 == 2_u16, '51725 % 7 == 2');\n    assert(1_u16 < 4_u16, '1 < 4');\n    assert(1_u16 <= 4_u16, '1 <= 4');\n    assert(!(4_u16 < 4_u16), '!(4 < 4)');\n    assert(4_u16 <= 4_u16, '4 <= 4');\n    assert(5_u16 > 2_u16, '5 > 2');\n    assert(5_u16 >= 2_u16, '5 >= 2');\n    assert(!(3_u16 > 3_u16), '!(3 > 3)');\n    assert(3_u16 >= 3_u16, '3 >= 3');\n}\n\n#[test]\n#[should_panic]\nfn test_u16_sub_overflow_1() {\n    0_u16 - 1_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_sub_overflow_2() {\n    0_u16 - 3_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_sub_overflow_3() {\n    1_u16 - 3_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_sub_overflow_4() {\n    100_u16 - 250_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_add_overflow_1() {\n    0x8000_u16 + 0x8000_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_add_overflow_2() {\n    0x9000_u16 + 0x8001_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_mul_overflow_1() {\n    0x100_u16 * 0x100_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_mul_overflow_2() {\n    0x101_u16 * 0x100_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_mul_overflow_3() {\n    2_u16 * 0x8000_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_div_by_0() {\n    2_u16 / 0_u16;\n}\n\n#[test]\n#[should_panic]\nfn test_u16_mod_by_0() {\n    0_u16 % 0_u16;\n}\n\n#[test]\nfn test_u32_operators() {\n    assert(1_u32 == 1_u32, '1 == 1');\n    assert(1_u32 != 2_u32, '1 != 2');\n    assert(1_u32 + 3_u32 == 4_u32, '1 + 3 == 4');\n    assert(3_u32 + 6_u32 == 9_u32, '3 + 6 == 9');\n    assert(3_u32 - 1_u32 == 2_u32, '3 - 1 == 2');\n    assert(231_u32 - 131_u32 == 100_u32, '231-131=100');\n    assert(1_u32 * 3_u32 == 3_u32, '1 * 3 == 3');\n    assert(2_u32 * 4_u32 == 8_u32, '2 * 4 == 8');\n    assert(510670725_u32 / 7_u32 == 72952960_u32, '510670725 / 7 == 72952960');\n    assert(510670725_u32 % 7_u32 == 5_u32, '510670725 % 7 == 5');\n    assert(1_u32 < 4_u32, '1 < 4');\n    assert(1_u32 <= 4_u32, '1 <= 4');\n    assert(!(4_u32 < 4_u32), '!(4 < 4)');\n    assert(4_u32 <= 4_u32, '4 <= 4');\n    assert(5_u32 > 2_u32, '5 > 2');\n    assert(5_u32 >= 2_u32, '5 >= 2');\n    assert(!(3_u32 > 3_u32), '!(3 > 3)');\n    assert(3_u32 >= 3_u32, '3 >= 3');\n}\n\n#[test]\n#[should_panic]\nfn test_u32_sub_overflow_1() {\n    0_u32 - 1_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_sub_overflow_2() {\n    0_u32 - 3_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_sub_overflow_3() {\n    1_u32 - 3_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_sub_overflow_4() {\n    100_u32 - 250_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_add_overflow_1() {\n    0x80000000_u32 + 0x80000000_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_add_overflow_2() {\n    0x90000000_u32 + 0x80000001_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_mul_overflow_1() {\n    0x10000_u32 * 0x10000_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_mul_overflow_2() {\n    0x10001_u32 * 0x10000_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_mul_overflow_3() {\n    2_u32 * 0x80000000_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_div_by_0() {\n    2_u32 / 0_u32;\n}\n\n#[test]\n#[should_panic]\nfn test_u32_mod_by_0() {\n    0_u32 % 0_u32;\n}\n\n#[test]\nfn test_u64_operators() {\n    assert(1_u64 == 1_u64, '1 == 1');\n    assert(1_u64 != 2_u64, '1 != 2');\n    assert(1_u64 + 3_u64 == 4_u64, '1 + 3 == 4');\n    assert(3_u64 + 6_u64 == 9_u64, '3 + 6 == 9');\n    assert(3_u64 - 1_u64 == 2_u64, '3 - 1 == 2');\n    assert(231_u64 - 131_u64 == 100_u64, '231-131=100');\n    assert(1_u64 * 3_u64 == 3_u64, '1 * 3 == 3');\n    assert(2_u64 * 4_u64 == 8_u64, '2 * 4 == 8');\n    assert(5010670477878974275_u64 / 7_u64 == 715810068268424896_u64, 'Wrong division result.');\n    assert(5010670477878974275_u64 % 7_u64 == 3_u64, '5010670477878974275 % 7 == 3');\n    assert(1_u64 < 4_u64, '1 < 4');\n    assert(1_u64 <= 4_u64, '1 <= 4');\n    assert(!(4_u64 < 4_u64), '!(4 < 4)');\n    assert(4_u64 <= 4_u64, '4 <= 4');\n    assert(5_u64 > 2_u64, '5 > 2');\n    assert(5_u64 >= 2_u64, '5 >= 2');\n    assert(!(3_u64 > 3_u64), '!(3 > 3)');\n    assert(3_u64 >= 3_u64, '3 >= 3');\n}\n\n#[test]\n#[should_panic]\nfn test_u64_sub_overflow_1() {\n    0_u64 - 1_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_sub_overflow_2() {\n    0_u64 - 3_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_sub_overflow_3() {\n    1_u64 - 3_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_sub_overflow_4() {\n    100_u64 - 250_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_add_overflow_1() {\n    0x8000000000000000_u64 + 0x8000000000000000_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_add_overflow_2() {\n    0x9000000000000000_u64 + 0x8000000000000001_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    0x100000000_u64 * 0x100000000_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_2() {\n    0x100000001_u64 * 0x100000000_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_3() {\n    2_u64 * 0x8000000000000000_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_div_by_0() {\n    2_u64 / 0_u64;\n}\n\n#[test]\n#[should_panic]\nfn test_u64_mod_by_0() {\n    0_u64 % 0_u64;\n}\n\n#[test]\nfn test_u128_operators() {\n    assert(1_u128 == 1_u128, '1 == 1');\n    assert(!(1_u128 == 2_u128), '!(1 == 2)');\n    assert(1_u128 + 3_u128 == 4_u128, '1 + 3 == 4');\n    assert(3_u128 + 6_u128 == 9_u128, '3 + 6 == 9');\n    assert(3_u128 - 1_u128 == 2_u128, '3 - 1 == 2');\n    assert(1231_u128 - 231_u128 == 1000_u128, '1231-231=1000');\n    assert(1_u128 * 3_u128 == 3_u128, '1 * 3 == 3');\n    assert(2_u128 * 4_u128 == 8_u128, '2 * 4 == 8');\n    assert(8_u128 / 2_u128 == 4_u128, '8 / 2 == 4');\n    assert(8_u128 % 2_u128 == 0_u128, '8 % 2 == 0');\n    assert(7_u128 / 3_u128 == 2_u128, '7 / 3 == 2');\n    assert(7_u128 % 3_u128 == 1_u128, '7 % 3 == 1');\n    assert(1_u128 < 4_u128, '1 < 4');\n    assert(1_u128 <= 4_u128, '1 <= 4');\n    assert(!(4_u128 < 4_u128), '!(4 < 4)');\n    assert(4_u128 <= 4_u128, '4 <= 4');\n    assert(5_u128 > 2_u128, '5 > 2');\n    assert(5_u128 >= 2_u128, '5 >= 2');\n    assert(!(3_u128 > 3_u128), '!(3 > 3)');\n    assert(3_u128 >= 3_u128, '3 >= 3');\n    assert((1_u128 | 2_u128) == 3_u128, '1 | 2 == 3');\n    assert((1_u128 & 2_u128) == 0_u128, '1 & 2 == 0');\n    assert((1_u128 ^ 2_u128) == 3_u128, '1 ^ 2 == 3');\n    assert((2_u128 | 2_u128) == 2_u128, '2 | 2 == 2');\n    assert((2_u128 & 2_u128) == 2_u128, '2 & 2 == 2');\n    assert((2_u128 & 3_u128) == 2_u128, '2 & 3 == 2');\n    assert((3_u128 ^ 6_u128) == 5_u128, '3 ^ 6 == 5');\n    assert(u128_sqrt(9_u128) == 3_u128, 'u128_sqrt(9) == 3');\n    assert(u128_sqrt(10_u128) == 3_u128, 'u128_sqrt(10) == 3');\n    assert(\n        u128_sqrt(1267650600228229401496703205376_u128) == 1125899906842624_u128,\n        'u128_sqrt(2^100) == 2^50'\n    );\n    assert(\n        u128_sqrt(340282366920938463463374607431768211455_u128) == 18446744073709551615_u128,\n        'Wrong square root result.'\n    );\n    assert(u128_sqrt(1_u128) == 1_u128, 'u128_sqrt(1) == 1');\n    assert(u128_sqrt(0_u128) == 0_u128, 'u128_sqrt(0) == 0');\n}\n\nfn pow_2_127() -> u128 {\n    0x80000000000000000000000000000000_u128\n}\n\nfn pow_2_64() -> u128 {\n    0x10000000000000000_u128\n}\n\n#[test]\n#[should_panic]\nfn test_u128_sub_overflow_1() {\n    0_u128 - 1_u128;\n}\n\n#[test]\n#[should_panic]\nfn test_u128_sub_overflow_2() {\n    0_u128 - 3_u128;\n}\n\n#[test]\n#[should_panic]\nfn test_u128_sub_overflow_3() {\n    1_u128 - 3_u128;\n}\n\n#[test]\n#[should_panic]\nfn test_u128_sub_overflow_4() {\n    100_u128 - 1000_u128;\n}\n\n#[test]\n#[should_panic]\nfn test_u128_add_overflow_1() {\n    pow_2_127() + pow_2_127();\n}\n\n#[test]\n#[should_panic]\nfn test_u128_add_overflow_2() {\n    (pow_2_127() + 12_u128) + pow_2_127();\n}\n\n#[test]\n#[should_panic]\nfn test_u128_mul_overflow_1() {\n    pow_2_64() * pow_2_64();\n}\n\n#[test]\n#[should_panic]\nfn test_u128_mul_overflow_2() {\n    (pow_2_64() + 1_u128) * pow_2_64();\n}\n\n#[test]\n#[should_panic]\nfn test_u128_mul_overflow_3() {\n    2_u128 * pow_2_127();\n}\n\n#[test]\n#[should_panic]\nfn test_u128_div_by_0() {\n    2_u128 / 0_u128;\n}\n\n#[test]\n#[should_panic]\nfn test_u128_mod_by_0() {\n    2_u128 % 0_u128;\n}\n\n// TODO(orizi): Remove when u256 literals are supported.\nfn as_u256(high: u128, low: u128) -> u256 {\n    u256 { low, high }\n}\n\n#[test]\nfn test_u256_from_felt252() {\n    assert(1.into() == as_u256(0_u128, 1_u128), 'into 1');\n    assert(\n        (170141183460469231731687303715884105728 * 2).into() == as_u256(1_u128, 0_u128),\n        'into 2**128'\n    );\n}\n\n// TODO(orizi): Use u256 literals when supported.\n#[test]\nfn test_u256_operators() {\n    let max_u128 = 0xffffffffffffffffffffffffffffffff_u128;\n    assert(as_u256(1_u128, 1_u128) + as_u256(3_u128, 2_u128) == as_u256(4_u128, 3_u128), 'no OF');\n    assert(\n        as_u256(1_u128, pow_2_127()) + as_u256(3_u128, pow_2_127()) == as_u256(5_u128, 0_u128),\n        'basic OF'\n    );\n    assert(as_u256(4_u128, 3_u128) - as_u256(1_u128, 1_u128) == as_u256(3_u128, 2_u128), 'no UF');\n    assert(\n        as_u256(5_u128, 0_u128) - as_u256(1_u128, pow_2_127()) == as_u256(3_u128, pow_2_127()),\n        'basic UF'\n    );\n    assert(\n        as_u256(4_u128, 3_u128) * as_u256(0_u128, 1_u128) == as_u256(4_u128, 3_u128), 'mul by 1'\n    );\n    assert(\n        as_u256(4_u128, 3_u128) * as_u256(0_u128, 2_u128) == as_u256(8_u128, 6_u128), 'mul by 2'\n    );\n    assert(\n        as_u256(0_u128, pow_2_127()) * as_u256(0_u128, 2_u128) == as_u256(1_u128, 0_u128),\n        'basic mul OF'\n    );\n    assert(\n        as_u256(0_u128, max_u128)\n            * as_u256(0_u128, max_u128) == as_u256(0xfffffffffffffffffffffffffffffffe_u128, 1_u128),\n        'max_u128 * max_u128'\n    );\n    assert(\n        as_u256(0_u128, max_u128) * as_u256(0_u128, 1_u128) == as_u256(0_u128, max_u128),\n        'max_u128 * 1'\n    );\n    assert(\n        as_u256(0_u128, 1_u128) * as_u256(0_u128, max_u128) == as_u256(0_u128, max_u128),\n        '1 * max_u128'\n    );\n    assert(\n        (as_u256(1_u128, 2_u128) | as_u256(2_u128, 2_u128)) == as_u256(3_u128, 2_u128),\n        '1.2|2.2==3.2'\n    );\n    assert(\n        (as_u256(2_u128, 1_u128) | as_u256(2_u128, 2_u128)) == as_u256(2_u128, 3_u128),\n        '2.1|2.2==2.3'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) | as_u256(1_u128, 2_u128)) == as_u256(3_u128, 2_u128),\n        '2.2|1.2==3.2'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) | as_u256(2_u128, 1_u128)) == as_u256(2_u128, 3_u128),\n        '2.2|2.1==2.3'\n    );\n    assert(\n        (as_u256(1_u128, 2_u128) & as_u256(2_u128, 2_u128)) == as_u256(0_u128, 2_u128),\n        '1.2&2.2==0.2'\n    );\n    assert(\n        (as_u256(2_u128, 1_u128) & as_u256(2_u128, 2_u128)) == as_u256(2_u128, 0_u128),\n        '2.1&2.2==2.0'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) & as_u256(1_u128, 2_u128)) == as_u256(0_u128, 2_u128),\n        '2.2&1.2==0.2'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) & as_u256(2_u128, 1_u128)) == as_u256(2_u128, 0_u128),\n        '2.2&2.1==2.0'\n    );\n    assert(\n        (as_u256(1_u128, 2_u128) ^ as_u256(2_u128, 2_u128)) == as_u256(3_u128, 0_u128),\n        '1.2^2.2==3.0'\n    );\n    assert(\n        (as_u256(2_u128, 1_u128) ^ as_u256(2_u128, 2_u128)) == as_u256(0_u128, 3_u128),\n        '2.1^2.2==0.3'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) ^ as_u256(1_u128, 2_u128)) == as_u256(3_u128, 0_u128),\n        '2.2^1.2==3.0'\n    );\n    assert(\n        (as_u256(2_u128, 2_u128) ^ as_u256(2_u128, 1_u128)) == as_u256(0_u128, 3_u128),\n        '2.2^2.1==0.3'\n    );\n    assert(as_u256(1_u128, 2_u128) < as_u256(2_u128, 2_u128), '1.2<2.2');\n    assert(as_u256(2_u128, 1_u128) < as_u256(2_u128, 2_u128), '2.1<2.2');\n    assert(!(as_u256(2_u128, 2_u128) < as_u256(1_u128, 2_u128)), '2.2<1.2');\n    assert(!(as_u256(2_u128, 2_u128) < as_u256(2_u128, 1_u128)), '2.2<2.1');\n    assert(!(as_u256(2_u128, 2_u128) < as_u256(2_u128, 2_u128)), '2.2<2.2');\n    assert(as_u256(1_u128, 2_u128) <= as_u256(2_u128, 2_u128), '1.2<=2.2');\n    assert(as_u256(2_u128, 1_u128) <= as_u256(2_u128, 2_u128), '2.1<=2.2');\n    assert(!(as_u256(2_u128, 2_u128) <= as_u256(1_u128, 2_u128)), '2.2<=1.2');\n    assert(!(as_u256(2_u128, 2_u128) <= as_u256(2_u128, 1_u128)), '2.2<=2.1');\n    assert(as_u256(2_u128, 2_u128) <= as_u256(2_u128, 2_u128), '2.2<=2.2');\n    assert(!(as_u256(1_u128, 2_u128) > as_u256(2_u128, 2_u128)), '1.2>2.2');\n    assert(!(as_u256(2_u128, 1_u128) > as_u256(2_u128, 2_u128)), '2.1>2.2');\n    assert(as_u256(2_u128, 2_u128) > as_u256(1_u128, 2_u128), '2.2>1.2');\n    assert(as_u256(2_u128, 2_u128) > as_u256(2_u128, 1_u128), '2.2>2.1');\n    assert(!(as_u256(2_u128, 2_u128) > as_u256(2_u128, 2_u128)), '2.2>2.2');\n    assert(!(as_u256(1_u128, 2_u128) >= as_u256(2_u128, 2_u128)), '1.2>=2.2');\n    assert(!(as_u256(2_u128, 1_u128) >= as_u256(2_u128, 2_u128)), '2.1>=2.2');\n    assert(as_u256(2_u128, 2_u128) >= as_u256(1_u128, 2_u128), '2.2>=1.2');\n    assert(as_u256(2_u128, 2_u128) >= as_u256(2_u128, 1_u128), '2.2>=2.1');\n    assert(as_u256(2_u128, 2_u128) >= as_u256(2_u128, 2_u128), '2.2>=2.2');\n}\n\n#[test]\n#[should_panic]\nfn test_u256_add_overflow() {\n    as_u256(pow_2_127(), 1_u128) + as_u256(pow_2_127(), 1_u128);\n}\n\n#[test]\n#[should_panic]\nfn test_u256_sub_overflow() {\n    as_u256(1_u128, 1_u128) - as_u256(1_u128, 2_u128);\n}\n\n#[test]\n#[should_panic]\nfn test_u256_mul_overflow_1() {\n    as_u256(1_u128, 1_u128) * as_u256(1_u128, 2_u128);\n}\n\n#[test]\n#[should_panic]\nfn test_u256_mul_overflow_2() {\n    as_u256(0_u128, pow_2_127()) * as_u256(2_u128, 0_u128);\n}\n\nfn test_array_helper() -> Array::<felt252> {\n    let mut arr = ArrayTrait::new();\n    arr.append(10);\n    arr.append(11);\n    arr.append(12);\n    arr\n}\n\n#[test]\nfn test_array() {\n    let arr = test_array_helper();\n    assert(*arr.at(0_usize) == 10, 'array[0] == 10');\n    assert(*arr.at(1_usize) == 11, 'array[1] == 11');\n    assert(*arr.at(2_usize) == 12, 'array[2] == 12');\n}\n\n#[test]\n#[should_panic]\nfn test_array_out_of_bound_1() {\n    let arr = test_array_helper();\n    arr.at(3_usize);\n}\n\n#[test]\n#[should_panic]\nfn test_array_out_of_bound_2() {\n    let arr = test_array_helper();\n    arr.at(11_usize);\n}\n\n#[test]\nfn test_felt252_clone() {\n    let felt252_snap = @2;\n    let felt252_clone = felt252_snap.clone();\n    assert(felt252_clone == 2, 'felt252_clone == 2');\n}\n\nuse clone::Clone;\nuse array::ArrayTCloneImpl;\n#[test]\n#[available_gas(100000)]\nfn test_array_clone() {\n    let felt252_snap_array = @test_array_helper();\n    let felt252_snap_array_clone = felt252_snap_array.clone();\n    assert(felt252_snap_array_clone.len() == 3_usize, 'array len == 3');\n    assert(*felt252_snap_array_clone.at(0_usize) == 10, 'array[0] == 10');\n    assert(*felt252_snap_array_clone.at(1_usize) == 11, 'array[1] == 11');\n    assert(*felt252_snap_array_clone.at(2_usize) == 12, 'array[2] == 12');\n}\n\n#[test]\nfn test_dict_new() -> Felt252Dict::<felt252> {\n    Felt252DictTrait::new()\n}\n\n#[test]\nfn test_dict_squash_empty() {\n    let mut dict: Felt252Dict::<felt252> = Felt252DictTrait::new();\n    let squashed_dict = dict.squash();\n}\n\n#[test]\nfn test_dict_default_val() {\n    let mut dict = Felt252DictTrait::new();\n    let default_val = dict.get(0);\n    let squashed_dict = dict.squash();\n    assert(default_val == 0, 'default_val == 0');\n}\n\n// TODO(Gil): Assert before the squash when drop will autosquash the dict.\n#[test]\nfn test_dict_write_read() {\n    let mut dict = Felt252DictTrait::new();\n    dict.insert(10, 110);\n    dict.insert(11, 111);\n    let val10 = dict.get(10);\n    let val11 = dict.get(11);\n    let val12 = dict.get(12);\n    let squashed_dict = dict.squash();\n    assert(val10 == 110, 'dict[10] == 110');\n    assert(val11 == 111, 'dict[11] == 111');\n    assert(val12 == 0, 'default_val == 0');\n}\n\n#[test]\nfn test_box_unbox_felt252s() {\n    let x = 10;\n    let boxed_x = BoxTrait::new(x);\n    let y = 11;\n    let boxed_y = BoxTrait::new(y);\n    assert(boxed_x.unbox() == 10, 'x == 10');\n    assert(boxed_y.unbox() == 11, 'y == 11');\n}\n\n\n// Test objects of size>1.\n#[test]\nfn test_box_unbox_u256() {\n    let x = as_u256(1_u128, 0_u128);\n    let boxed_x = BoxTrait::new(x);\n    let y = as_u256(1_u128, 1_u128);\n    let boxed_y = BoxTrait::new(y);\n    assert(boxed_x.unbox() == as_u256(1_u128, 0_u128), 'unbox u256 x');\n    assert(boxed_y.unbox() == as_u256(1_u128, 1_u128), 'unbox u256 y');\n}\n\n#[test]\nfn test_span() {\n    let mut span = test_array_helper().span();\n\n    assert(span.len() == 3_u32, 'Unexpected span length.');\n    assert(*span.get(0_u32).unwrap().unbox() == 10, 'Unexpected element');\n    assert(*span.pop_front().unwrap() == 10, 'Unexpected element');\n    assert(span.len() == 2_u32, 'Unexpected span length.');\n    assert(*span.at(1_u32) == 12, 'Unexpected element');\n}\n\n#[test]\nfn test_get_available_gas_no_gas_supply() {\n    assert(testing::get_available_gas() == 0_u128, 'expected no_gas_supply')\n}\n\n#[test]\n#[available_gas(10000)]\nfn test_get_available_gas_with_gas_supply() {\n    assert(testing::get_available_gas() > 5000_u128, 'high amount of gas used')\n}\n",
    "metadata": {
      "name": "test.cairo"
    }
  },
  {
    "pageContent": "extern fn get_available_gas() -> u128 implicits(GasBuiltin) nopanic;\n",
    "metadata": {
      "name": "testing.cairo"
    }
  },
  {
    "pageContent": "trait Copy<T>;\ntrait Drop<T>;\n\n// TODO(spapini): When associated types are supported, support the general trait Add<X, Y>.\ntrait Add<T> {\n    fn add(a: T, b: T) -> T;\n}\ntrait AddEq<T> {\n    fn add_eq(ref self: T, other: T);\n}\n\n// TODO(spapini): When associated types are supported, support the general trait Sub<X, Y>.\ntrait Sub<T> {\n    fn sub(a: T, b: T) -> T;\n}\ntrait SubEq<T> {\n    fn sub_eq(ref self: T, other: T);\n}\n\n// TODO(spapini): When associated types are supported, support the general trait Mul<X, Y>.\ntrait Mul<T> {\n    fn mul(a: T, b: T) -> T;\n}\ntrait MulEq<T> {\n    fn mul_eq(ref self: T, other: T);\n}\n\n// TODO(spapini): When associated types are supported, support the general trait Div<X, Y>.\ntrait Div<T> {\n    fn div(a: T, b: T) -> T;\n}\ntrait DivEq<T> {\n    fn div_eq(ref self: T, other: T);\n}\n\n// TODO(spapini): When associated types are supported, support the general trait Rem<X, Y>.\ntrait Rem<T> {\n    fn rem(a: T, b: T) -> T;\n}\ntrait RemEq<T> {\n    fn rem_eq(ref self: T, other: T);\n}\n\ntrait PartialEq<T> {\n    fn eq(a: T, b: T) -> bool;\n    fn ne(a: T, b: T) -> bool;\n}\n\n// TODO(spapini): When associated types are supported, support the general trait BitAnd<X, Y>.\ntrait BitAnd<T> {\n    fn bitand(a: T, b: T) -> T;\n}\n\n// TODO(spapini): When associated types are supported, support the general trait BitOr<X, Y>.\ntrait BitOr<T> {\n    fn bitor(a: T, b: T) -> T;\n}\n\n// TODO(spapini): When associated types are supported, support the general trait BitXor<X, Y>.\ntrait BitXor<T> {\n    fn bitxor(a: T, b: T) -> T;\n}\n\ntrait PartialOrd<T> {\n    fn le(a: T, b: T) -> bool;\n    fn ge(a: T, b: T) -> bool;\n    fn lt(a: T, b: T) -> bool;\n    fn gt(a: T, b: T) -> bool;\n}\n\n/// Trait for convertion between types.\ntrait Into<T, S> {\n    fn into(self: T) -> S;\n}\n\n/// Trait for fallible convertion between types.\ntrait TryInto<T, S> {\n    fn try_into(self: T) -> Option<S>;\n}\n\ntrait Neg<T> {\n    fn neg(a: T) -> T;\n}\n\ntrait Not<T> {\n    fn not(a: T) -> T;\n}\n\ntrait Destruct<T> {\n    fn destruct(self: T) nopanic;\n}\n\n// TODO(spapini): Remove this, it can lead to multiple impls and unwanted Destruct implementation.\nimpl DestructFromDrop<T, impl TDrop: Drop::<T>> of Destruct::<T> {\n    #[inline(always)]\n    fn destruct(self: T) nopanic {}\n}\n",
    "metadata": {
      "name": "traits.cairo"
    }
  },
  {
    "pageContent": "trait Zeroable<T> {\n    /// Returns the additive identity element of Self, 0.\n    fn zero() -> T;\n    /// Returns whether self is equal to 0, the additive identity element.\n    fn is_zero(self: T) -> bool;\n    /// Returns whether self is not equal to 0, the additive identity element.\n    fn is_non_zero(self: T) -> bool;\n}\n\nimpl Felt252Zeroable of Zeroable::<felt252> {\n    fn zero() -> felt252 {\n        0\n    }\n\n    #[inline(always)]\n    fn is_zero(self: felt252) -> bool {\n        self == 0\n    }\n\n    #[inline(always)]\n    fn is_non_zero(self: felt252) -> bool {\n        !self.is_zero()\n    }\n}\n",
    "metadata": {
      "name": "zeroable.cairo"
    }
  },
  {
    "pageContent": "\nfn foo(x: T) -> S {\n    // Cascaded dangling break\n    let x1 = 1+2+3+4+5+6+7+8+9+1*2*3*4*5*6*7*8*9*1*2*3*4*5*6*7*8*9*1*2*3*4*5*6*7*8*9+1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9;\n    // Non-dangling break (overridden)\n    let x2 = a_very_very_very_very_very_very_very_long_name()+a_very_very_very_very_very_very_very_long_name();\n    let x3 = (1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9);\n    let x4 = (1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9);\n    let x5 = (1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9+1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9)+(1+2+3+4+5+6+7+8+9);\n    let x6 = (1+0+(2+0+(3+0+(4+0+(5+0+(6+0+(7+0+(8+0+(9+0+(1+0+(2+0+(3+0+(4+0)))))))))))));\n    }\n\nfn bar(first_arg: T, second_arg: T, third_arg: T, fourth_arg: T, fifth_arg: T, sixth_arg: T, seventh_arg: T,) -> T {\n    let x = Struct{first_arg: first_arg, second_arg: second_arg, third_arg: third_arg, fourth_arg: fourth_arg, fifth_arg: fifth_arg};\n}\n",
    "metadata": {
      "name": "linebreaking.cairo"
    }
  },
  {
    "pageContent": "\n// try\n                // try2\nfn foo (x:T) -> S { let x = -    5 + 3; let y : T = x         * 2 + 3-5;// Comment.\n\n\n\nlet z = 5; z +=4; 5 + Struct{a: 5, b: Struct2{_gg: ()}}; let df =6;{let k = 1; let z = 1; let block={y+1; x+5};}\n\n { // Comment.\n\n\n\n   6;\n\n\n// 445.\n\n\n\n   5; // Comment.\n\n   } // Comment.\n\n   // A long comment that shouldn't affect the breaking of the next line. Make it a little longer.\n    let var = 1 + 2 + 3;\n}\n\nfn bar < T > (x:T)->T{\nlet x:T=1;}\n\n\nstruct A{} struct B{}\n\n// Calculates fib, but all variables are boxes.\nfn fib(a: Box::<felt252>, b: Box::<felt252>, n: Box::<felt252>) -> Box::<felt252> {\n    match n {\n        0 => { a },\n        _ => {\n            fib(\n                b,\n                into_box::<felt252>(unbox::<felt252>(a) + unbox::<felt252>(b)),\n\n                into_box::<felt252>(unbox::<felt252>(n) - 1),\n            )\n        },\n    }\n}\n",
    "metadata": {
      "name": "test1.cairo"
    }
  },
  {
    "pageContent": "fn foo(x: T) -> S {\n    // Cascaded dangling break\n    let x1 = 1\n        + 2\n        + 3\n        + 4\n        + 5\n        + 6\n        + 7\n        + 8\n        + 9\n        + 1\n            * 2\n            * 3\n            * 4\n            * 5\n            * 6\n            * 7\n            * 8\n            * 9\n            * 1\n            * 2\n            * 3\n            * 4\n            * 5\n            * 6\n            * 7\n            * 8\n            * 9\n            * 1\n            * 2\n            * 3\n            * 4\n            * 5\n            * 6\n            * 7\n            * 8\n            * 9\n        + 1\n        + 2\n        + 3\n        + 4\n        + 5\n        + 6\n        + 7\n        + 8\n        + 9\n        + 1\n        + 2\n        + 3\n        + 4\n        + 5\n        + 6\n        + 7\n        + 8\n        + 9;\n    // Non-dangling break (overridden)\n    let x2 = a_very_very_very_very_very_very_very_long_name()\n        + a_very_very_very_very_very_very_very_long_name();\n    let x3 = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9);\n    let x4 = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9);\n    let x5 = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1\n            + 2\n            + 3\n            + 4\n            + 5\n            + 6\n            + 7\n            + 8\n            + 9\n            + 1\n            + 2\n            + 3\n            + 4\n            + 5\n            + 6\n            + 7\n            + 8\n            + 9\n            + 1\n            + 2\n            + 3\n            + 4\n            + 5\n            + 6\n            + 7\n            + 8\n            + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9)\n        + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9);\n    let x6 = (1\n        + 0\n        + (2\n            + 0\n            + (3\n                + 0\n                + (4\n                    + 0\n                    + (5\n                        + 0\n                        + (6\n                            + 0\n                            + (7\n                                + 0\n                                + (8 + 0 + (9 + 0 + (1 + 0 + (2 + 0 + (3 + 0 + (4 + 0)))))))))))));\n}\n\nfn bar(\n    first_arg: T,\n    second_arg: T,\n    third_arg: T,\n    fourth_arg: T,\n    fifth_arg: T,\n    sixth_arg: T,\n    seventh_arg: T,\n) -> T {\n    let x = Struct {\n        first_arg: first_arg,\n        second_arg: second_arg,\n        third_arg: third_arg,\n        fourth_arg: fourth_arg,\n        fifth_arg: fifth_arg\n    };\n}\n",
    "metadata": {
      "name": "linebreaking.cairo"
    }
  },
  {
    "pageContent": "// try\n// try2\nfn foo(x: T) -> S {\n    let x = -5 + 3;\n    let y: T = x * 2 + 3 - 5; // Comment.\n\n    let z = 5;\n    z += 4;\n    5 + Struct { a: 5, b: Struct2 { _gg: () } };\n    let df = 6;\n    {\n        let k = 1;\n        let z = 1;\n        let block = {\n            y + 1;\n            x + 5\n        };\n    }\n\n    { // Comment.\n        6;\n\n        // 445.\n\n        5; // Comment.\n    } // Comment.\n\n    // A long comment that shouldn't affect the breaking of the next line. Make it a little longer.\n    let var = 1 + 2 + 3;\n}\n\nfn bar<T>(x: T) -> T {\n    let x: T = 1;\n}\n\n\nstruct A {}\nstruct B {}\n\n// Calculates fib, but all variables are boxes.\nfn fib(a: Box::<felt252>, b: Box::<felt252>, n: Box::<felt252>) -> Box::<felt252> {\n    match n {\n        0 => {\n            a\n        },\n        _ => {\n            fib(\n                b,\n                into_box::<felt252>(unbox::<felt252>(a) + unbox::<felt252>(b)),\n                into_box::<felt252>(unbox::<felt252>(n) - 1),\n            )\n        },\n    }\n}\n",
    "metadata": {
      "name": "test1.cairo"
    }
  },
  {
    "pageContent": ";\n#[attr]\nfn foo(var1: int var2: felt252) -> int {\n    let bla = 7 + true + 'abc'; // comment\n    return bar(bla);\n}\n",
    "metadata": {
      "name": "colored.cairo"
    }
  },
  {
    "pageContent": "use std::format;\n\nfn foo(a: int) -> felt252 {\n    return a;\n}\n",
    "metadata": {
      "name": "short.cairo"
    }
  },
  {
    "pageContent": "mod submod;\nuse submod::something;\n\n// Func foo\n// Second line\n;\nfn foo(,var1: int,, mut ref var2: felt252,) -> int {\n    let bla3 = --7; // succeeds, ok\n    let bla4 = -!-!8; // succeeds, ok\n    let x = 1;\n    let y = match x {\n        0 => { 1 },\n        _ => 0,\n    };\n    let z = if 0 + x == y {\n        1\n    } else {\n        2\n    };\n    let block_combination = {5} + match x { E::V1(_) => 4, E::V2(_) => 2 }\n        - if cond { 32 } else { 1 };\n    let w = calc_with_error(x, y?, z)?;\n    let member_value = value.member?;\n    let method_return = value.method()?;\n    let x = true; // bla1\n                  // bla2\n    z = 5;\n    func1(x);\n    func2::<int>(x)\n    return x;\n\nfn bar<A, B>() -> felt252 { }\n\nextern type S<>;\nextern fn glee<A, b>(var1: int,) -> crate::S<int> nopanic;\n\nstruct A<A, B> {\n    member: bool,\n    member2: (bool, felt252, ())\n}\n\ntype Renamed = submod::inner::Other;\ntype Generic<T> = super::other::OtherGeneric::<T>;\n",
    "metadata": {
      "name": "test1.cairo"
    }
  },
  {
    "pageContent": "fn foo (x:T) -> S\n{\n    let x = -5 + 3;\n    let y : T = x*2 + 3*5; // Comment.\n    let z = ;\n    5 + Struct{a: 5, b: Struct2{_gg: ()}};\n    return df == 6;\n    x + y\n}\n\nmod my_mod{\n    fn bar (x:T0, s: S) -> X {\n        x.a *+-. s.s * foo(1,3)\n    }\n    struct A{\n        x: a, // Comment.\n        y: int\n    }\n\n}\n\nskipped tokens\n",
    "metadata": {
      "name": "test2.cairo"
    }
  },
  {
    "pageContent": "fn main() -> Option<felt252> {\n    fib(1, 1, 13)\n}\n\n/// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> Option<felt252> {\n    gas::withdraw_gas()?;\n    match n {\n        0 => Option::Some(a),\n        _ => fib(b, a + b, n - 1),\n    }\n}\n",
    "metadata": {
      "name": "test3.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nuse array::SpanTrait;\nuse box::BoxTrait;\nuse option::OptionTrait;\nuse starknet::ContractAddressZeroable;\nuse starknet::ContractAddressIntoFelt252;\nuse traits::Into;\nuse zeroable::Zeroable;\n\n#[contract]\nmod TestContract {\n    use array::ArrayTrait;\n    use traits::Into;\n    use starknet::StorageAddress;\n    use starknet::storage_access::StorageAddressSerde;\n\n    struct Storage {\n        value: felt252,\n        mapping: LegacyMap::<u128, bool>,\n        large_mapping: LegacyMap::<u256, u256>,\n    }\n\n    #[view]\n    fn get_plus_2(a: felt252) -> felt252 {\n        a + 2\n    }\n\n    #[view]\n    fn get_appended_array(mut arr: Array::<felt252>) -> Array::<felt252> {\n        let elem = arr.len().into();\n        arr.append(elem);\n        arr\n    }\n\n    #[external]\n    fn set_value(a: felt252) {\n        value::write(a);\n    }\n\n    #[view]\n    fn get_value() -> felt252 {\n        value::read()\n    }\n\n    #[external]\n    fn insert(key: u128) {\n        mapping::write(key, true)\n    }\n\n    #[external]\n    fn remove(key: u128) {\n        mapping::write(key, false)\n    }\n\n    #[view]\n    fn contains(key: u128) -> bool {\n        mapping::read(key)\n    }\n\n    #[external]\n    fn set_large(key: u256, value: u256) {\n        large_mapping::write(key, value)\n    }\n\n    #[view]\n    fn get_large(key: u256) -> u256 {\n        large_mapping::read(key)\n    }\n\n    #[view]\n    fn test_storage_address(storage_address: StorageAddress) -> StorageAddress {\n        storage_address\n    }\n}\n\n#[test]\n#[should_panic]\nfn test_wrapper_not_enough_args() {\n    TestContract::__external::get_plus_2(ArrayTrait::new().span());\n}\n\n#[test]\n#[should_panic]\nfn test_wrapper_too_many_enough_args() {\n    let mut calldata = ArrayTrait::new();\n    calldata.append(1);\n    calldata.append(2);\n    TestContract::__external::get_plus_2(calldata.span());\n}\n\nfn serialized_element<T, impl TSerde: serde::Serde::<T>, impl TDestruct: Destruct::<T>>(\n    value: T\n) -> Span::<felt252> {\n    let mut arr = ArrayTrait::new();\n    serde::Serde::serialize(ref arr, value);\n    arr.span()\n}\n\nfn single_deserialize<T, impl TSerde: serde::Serde::<T>>(ref data: Span::<felt252>) -> T {\n    serde::Serde::deserialize(ref data).expect('missing data')\n}\n\n#[test]\n#[available_gas(20000)]\nfn test_wrapper_valid_args() {\n    let mut retdata = TestContract::__external::get_plus_2(serialized_element(1));\n    assert(single_deserialize(ref retdata) == 3, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(5000)]\n#[should_panic]\nfn test_wrapper_valid_args_out_of_gas() {\n    TestContract::__external::get_plus_2(serialized_element(1));\n}\n\n#[test]\n#[available_gas(200000)]\nfn test_wrapper_array_arg_and_output() {\n    let mut calldata = ArrayTrait::new();\n    calldata.append(1);\n    calldata.append(2);\n    let mut retdata = TestContract::__external::get_appended_array(calldata.span());\n    assert(single_deserialize(ref retdata) == 2, 'Wrong length');\n    assert(single_deserialize(ref retdata) == 2, 'Wrong original value');\n    assert(single_deserialize(ref retdata) == 1, 'Wrong added value');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(200000)]\nfn read_first_value() {\n    let mut retdata = TestContract::__external::get_value(ArrayTrait::new().span());\n    assert(single_deserialize(ref retdata) == 0, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn write_read_value() {\n    assert(TestContract::__external::set_value(serialized_element(4)).is_empty(), 'Not empty');\n    let mut retdata = TestContract::__external::get_value(ArrayTrait::new().span());\n    assert(single_deserialize(ref retdata) == 4, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(200000)]\nfn empty_start() {\n    let mut retdata = TestContract::__external::contains(serialized_element(4));\n    assert(single_deserialize(ref retdata) == 0, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn contains_added() {\n    assert(TestContract::__external::insert(serialized_element(4)).is_empty(), 'Not empty');\n    let mut retdata = TestContract::__external::contains(serialized_element(4));\n    assert(single_deserialize(ref retdata) == 1, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n    let mut retdata = TestContract::__external::contains(serialized_element(5));\n    assert(single_deserialize(ref retdata) == 0, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn not_contains_removed() {\n    assert(TestContract::__external::insert(serialized_element(4)).is_empty(), 'Not empty');\n    assert(TestContract::__external::remove(serialized_element(4)).is_empty(), 'Not empty');\n    let mut retdata = TestContract::__external::contains(serialized_element(4));\n    assert(single_deserialize(ref retdata) == 0, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn read_large_first_value() {\n    let mut retdata = TestContract::__external::get_large(\n        serialized_element(u256 { low: 1_u128, high: 2_u128 })\n    );\n    assert(single_deserialize(ref retdata) == u256 { low: 0_u128, high: 0_u128 }, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn write_read_large_value() {\n    let mut args = ArrayTrait::new();\n    serde::Serde::serialize(ref args, u256 { low: 1_u128, high: 2_u128 });\n    serde::Serde::serialize(ref args, u256 { low: 3_u128, high: 4_u128 });\n    let mut retdata = TestContract::__external::set_large(args.span());\n    assert(retdata.is_empty(), 'Array not empty');\n    let mut retdata = TestContract::__external::get_large(\n        serialized_element(u256 { low: 1_u128, high: 2_u128 })\n    );\n    assert(single_deserialize(ref retdata) == u256 { low: 3_u128, high: 4_u128 }, 'Wrong result');\n    assert(retdata.is_empty(), 'Array not empty');\n}\n\n#[test]\n#[available_gas(300000)]\nfn test_get_block_info() {\n    let info = starknet::get_block_info().unbox();\n    assert(info.block_number == 0_u64, 'non default block_number');\n    assert(info.block_timestamp == 0_u64, 'non default block_timestamp');\n    assert(info.sequencer_address.is_zero(), 'non default sequencer_address');\n    starknet::testing::set_block_number(1_u64);\n    starknet::testing::set_block_timestamp(2_u64);\n    starknet::testing::set_sequencer_address(starknet::contract_address_const::<3>());\n    let info = starknet::get_block_info().unbox();\n    assert(info.block_number == 1_u64, 'block_number not set');\n    assert(info.block_timestamp == 2_u64, 'block_timestamp not set');\n    assert(info.sequencer_address.into() == 3, 'sequencer_address not set');\n}\n\n#[test]\n#[available_gas(300000)]\nfn test_get_caller_address() {\n    assert(starknet::get_caller_address().is_zero(), 'non default value');\n    starknet::testing::set_caller_address(starknet::contract_address_const::<1>());\n    assert(starknet::get_caller_address().into() == 1, 'not set value');\n}\n\n#[test]\n#[available_gas(300000)]\nfn test_get_contract_address() {\n    assert(starknet::get_contract_address().is_zero(), 'non default value');\n    starknet::testing::set_contract_address(starknet::contract_address_const::<1>());\n    assert(starknet::get_contract_address().into() == 1, 'not set value');\n}\n\n#[test]\n#[should_panic]\nfn test_out_of_range_storage_address_from_felt252() -> starknet::StorageAddress {\n    starknet::storage_address_try_from_felt252(-1).unwrap()\n}\n\n#[test]\n#[available_gas(300000)]\nfn test_storage_address() {\n    let mut args = ArrayTrait::new();\n    args.append(0x17);\n    let storage_address = starknet::storage_address_try_from_felt252(0x17).unwrap();\n    let ret_data = TestContract::__external::test_storage_address(args.span());\n\n    assert(*args.at(0_u32) == *ret_data.at(0_u32), 'Unexpected ret_data.');\n}\n",
    "metadata": {
      "name": "lib.cairo"
    }
  },
  {
    "pageContent": "use serde::Serde;\nuse starknet::ContractAddress;\nuse starknet::contract_address::ContractAddressSerde;\nuse array::ArrayTrait;\nuse array::SpanTrait;\n\n#[account_contract]\nmod Account {\n    use array::ArrayTrait;\n    use array::SpanTrait;\n    use box::BoxTrait;\n    use ecdsa::check_ecdsa_signature;\n    use option::OptionTrait;\n    use super::Call;\n    use super::ArrayCallSerde;\n    use super::ArrayCallDrop;\n    use starknet::ContractAddress;\n    use starknet::ContractAddressZeroable;\n    use zeroable::Zeroable;\n\n    struct Storage {\n        public_key: felt252\n    }\n\n    #[constructor]\n    fn constructor(public_key_: felt252) {\n        public_key::write(public_key_);\n    }\n\n    fn validate_transaction() -> felt252 {\n        let tx_info = starknet::get_tx_info().unbox();\n        let signature = tx_info.signature;\n        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n        assert(\n            check_ecdsa_signature(\n                message_hash: tx_info.transaction_hash,\n                public_key: public_key::read(),\n                signature_r: *signature.at(0_u32),\n                signature_s: *signature.at(1_u32),\n            ),\n            'INVALID_SIGNATURE',\n        );\n\n        starknet::VALIDATED\n    }\n\n\n    #[external]\n    fn __validate_deploy__(\n        class_hash: felt252, contract_address_salt: felt252, public_key_: felt252\n    ) -> felt252 {\n        validate_transaction()\n    }\n\n    #[external]\n    fn __validate_declare__(class_hash: felt252) -> felt252 {\n        validate_transaction()\n    }\n\n    #[external]\n    fn __validate__(\n        contract_address: ContractAddress, entry_point_selector: felt252, calldata: Array::<felt252>\n    ) -> felt252 {\n        validate_transaction()\n    }\n\n    #[external]\n    #[raw_output]\n    fn __execute__(mut calls: Array<Call>) -> Span::<felt252> {\n        // Validate caller.\n        assert(starknet::get_caller_address().is_zero(), 'INVALID_CALLER');\n\n        // Check the tx version here, since version 0 transaction skip the __validate__ function.\n        let tx_info = starknet::get_tx_info().unbox();\n        assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n\n        // TODO(ilya): Implement multi call.\n        assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED');\n        let Call{to, selector, calldata } = calls.pop_front().unwrap();\n\n        starknet::call_contract_syscall(\n            address: to, entry_point_selector: selector, calldata: calldata.span()\n        ).unwrap_syscall()\n    }\n}\n\nstruct Call {\n    to: ContractAddress,\n    selector: felt252,\n    calldata: Array<felt252>\n}\n\nimpl ArrayCallDrop of Drop::<Array<Call>>;\n\nimpl CallSerde of Serde::<Call> {\n    fn serialize(ref output: Array<felt252>, input: Call) {\n        let Call{to, selector, calldata } = input;\n        Serde::serialize(ref output, to);\n        Serde::serialize(ref output, selector);\n        Serde::serialize(ref output, calldata);\n    }\n\n    fn deserialize(ref serialized: Span<felt252>) -> Option<Call> {\n        let to = Serde::<ContractAddress>::deserialize(ref serialized)?;\n        let selector = Serde::<felt252>::deserialize(ref serialized)?;\n        let calldata = Serde::<Array::<felt252>>::deserialize(ref serialized)?;\n        Option::Some(Call { to, selector, calldata })\n    }\n}\n\nimpl ArrayCallSerde of Serde::<Array<Call>> {\n    fn serialize(ref output: Array<felt252>, mut input: Array<Call>) {\n        Serde::<usize>::serialize(ref output, input.len());\n        serialize_array_call_helper(ref output, input);\n    }\n\n    fn deserialize(ref serialized: Span<felt252>) -> Option<Array<Call>> {\n        let length = *serialized.pop_front()?;\n        let mut arr = ArrayTrait::new();\n        deserialize_array_call_helper(ref serialized, arr, length)\n    }\n}\n\nfn serialize_array_call_helper(ref output: Array<felt252>, mut input: Array<Call>) {\n    // TODO(orizi): Replace with simple call once inlining is supported.\n    match gas::withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('Out of gas');\n            panic(data);\n        },\n    }\n    match input.pop_front() {\n        Option::Some(value) => {\n            Serde::<Call>::serialize(ref output, value);\n            serialize_array_call_helper(ref output, input);\n        },\n        Option::None(_) => {},\n    }\n}\n\nfn deserialize_array_call_helper(\n    ref serialized: Span<felt252>, mut curr_output: Array<Call>, remaining: felt252\n) -> Option<Array<Call>> {\n    if remaining == 0 {\n        return Option::Some(curr_output);\n    }\n\n    // TODO(orizi): Replace with simple call once inlining is supported.\n    match gas::withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('Out of gas');\n            panic(data);\n        },\n    }\n\n    curr_output.append(Serde::<Call>::deserialize(ref serialized)?);\n    deserialize_array_call_helper(ref serialized, curr_output, remaining - 1)\n}\n",
    "metadata": {
      "name": "account.cairo"
    }
  },
  {
    "pageContent": "#[contract]\nmod ERC20 {\n    use zeroable::Zeroable;\n    use starknet::get_caller_address;\n    use starknet::contract_address_const;\n    use starknet::ContractAddress;\n    use starknet::ContractAddressZeroable;\n\n    struct Storage {\n        name: felt252,\n        symbol: felt252,\n        decimals: u8,\n        total_supply: u256,\n        balances: LegacyMap::<ContractAddress, u256>,\n        allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>,\n    }\n\n    #[event]\n    fn Transfer(from: ContractAddress, to: ContractAddress, value: u256) {}\n\n    #[event]\n    fn Approval(owner: ContractAddress, spender: ContractAddress, value: u256) {}\n\n    #[constructor]\n    fn constructor(\n        name_: felt252,\n        symbol_: felt252,\n        decimals_: u8,\n        initial_supply: u256,\n        recipient: ContractAddress\n    ) {\n        name::write(name_);\n        symbol::write(symbol_);\n        decimals::write(decimals_);\n        assert(!recipient.is_zero(), 'ERC20: mint to the 0 address');\n        total_supply::write(initial_supply);\n        balances::write(recipient, initial_supply);\n        Transfer(contract_address_const::<0>(), recipient, initial_supply);\n    }\n\n    #[view]\n    fn get_name() -> felt252 {\n        name::read()\n    }\n\n    #[view]\n    fn get_symbol() -> felt252 {\n        symbol::read()\n    }\n\n    #[view]\n    fn get_decimals() -> u8 {\n        decimals::read()\n    }\n\n    #[view]\n    fn get_total_supply() -> u256 {\n        total_supply::read()\n    }\n\n    #[view]\n    fn balance_of(account: ContractAddress) -> u256 {\n        balances::read(account)\n    }\n\n    #[view]\n    fn allowance(owner: ContractAddress, spender: ContractAddress) -> u256 {\n        allowances::read((owner, spender))\n    }\n\n    #[external]\n    fn transfer(recipient: ContractAddress, amount: u256) {\n        let sender = get_caller_address();\n        transfer_helper(sender, recipient, amount);\n    }\n\n    #[external]\n    fn transfer_from(sender: ContractAddress, recipient: ContractAddress, amount: u256) {\n        let caller = get_caller_address();\n        spend_allowance(sender, caller, amount);\n        transfer_helper(sender, recipient, amount);\n    }\n\n    #[external]\n    fn approve(spender: ContractAddress, amount: u256) {\n        let caller = get_caller_address();\n        approve_helper(caller, spender, amount);\n    }\n\n    #[external]\n    fn increase_allowance(spender: ContractAddress, added_value: u256) {\n        let caller = get_caller_address();\n        approve_helper(caller, spender, allowances::read((caller, spender)) + added_value);\n    }\n\n    #[external]\n    fn decrease_allowance(spender: ContractAddress, subtracted_value: u256) {\n        let caller = get_caller_address();\n        approve_helper(caller, spender, allowances::read((caller, spender)) - subtracted_value);\n    }\n\n    fn transfer_helper(sender: ContractAddress, recipient: ContractAddress, amount: u256) {\n        assert(!sender.is_zero(), 'ERC20: transfer from 0');\n        assert(!recipient.is_zero(), 'ERC20: transfer to 0');\n        balances::write(sender, balances::read(sender) - amount);\n        balances::write(recipient, balances::read(recipient) + amount);\n        Transfer(sender, recipient, amount);\n    }\n\n    fn spend_allowance(owner: ContractAddress, spender: ContractAddress, amount: u256) {\n        let current_allowance = allowances::read((owner, spender));\n        let ONES_MASK = 0xffffffffffffffffffffffffffffffff_u128;\n        let is_unlimited_allowance =\n            current_allowance.low == ONES_MASK & current_allowance.high == ONES_MASK;\n        if !is_unlimited_allowance {\n            approve_helper(owner, spender, current_allowance - amount);\n        }\n    }\n\n    fn approve_helper(owner: ContractAddress, spender: ContractAddress, amount: u256) {\n        assert(!spender.is_zero(), 'ERC20: approve from 0');\n        allowances::write((owner, spender), amount);\n        Approval(owner, spender, amount);\n    }\n}\n",
    "metadata": {
      "name": "erc20.cairo"
    }
  },
  {
    "pageContent": "#[contract]\nmod HelloStarknet {\n    struct Storage {\n        balance: felt252, \n    }\n\n    // Increases the balance by the given amount.\n    #[external]\n    fn increase_balance(amount: felt252) {\n        balance::write(balance::read() + amount);\n    }\n\n    // Returns the current balance.\n    #[view]\n    fn get_balance() -> felt252 {\n        balance::read()\n    }\n}\n",
    "metadata": {
      "name": "hello_starknet.cairo"
    }
  },
  {
    "pageContent": "#[contract]\nmod MinimalContract {\n    #[external]\n    fn empty() {}\n}\n",
    "metadata": {
      "name": "minimal_contract.cairo"
    }
  },
  {
    "pageContent": "#[abi]\ntrait IAnotherContract {\n    fn foo(a: u128) -> u128;\n}\n\n\n#[contract]\nmod TestContract {\n    use super::IAnotherContractDispatcherTrait;\n    use super::IAnotherContractDispatcher;\n    use super::IAnotherContractLibraryDispatcher;\n    use dict::Felt252DictTrait;\n\n    struct Storage {\n        my_storage_var: felt252\n    }\n\n    fn internal_func() -> felt252 {\n        1\n    }\n\n    #[external]\n    fn test(ref arg: felt252, arg1: felt252, arg2: felt252) -> felt252 {\n        let mut x = my_storage_var::read();\n        x += 1;\n        my_storage_var::write(x);\n        x + internal_func()\n    }\n\n    #[external]\n    fn call_foo(another_contract_address: starknet::ContractAddress, a: u128) -> u128 {\n        IAnotherContractDispatcher { contract_address: another_contract_address }.foo(a)\n    }\n\n    #[external]\n    fn libcall_foo(a: u128) -> u128 {\n        IAnotherContractLibraryDispatcher { class_hash: starknet::class_hash_const::<0>() }.foo(a)\n    }\n\n    /// An external method that requires the `segment_arena` builtin.\n    #[external]\n    fn segment_arena_builtin() {\n        let x = felt252_dict_new::<felt252>();\n        x.squash();\n    }\n\n    #[l1_handler]\n    fn l1_handle(arg: felt252) -> felt252 {\n        arg\n    }\n}\n",
    "metadata": {
      "name": "test_contract.cairo"
    }
  },
  {
    "pageContent": "impl MyCopy of Copy::<Option<(felt252, felt252)>>;\n\nfn foo(x: Option<(felt252, felt252)>) -> Option<felt252> {\n    let y = x;\n    match x {\n        Option::Some(x) => {\n            let (x, y) = x;\n            Option::Some(x)\n        },\n        // TODO(spapini): Replace with _.\n        Option::None(o) => {\n            return Option::None(());\n        },\n    }\n}\n",
    "metadata": {
      "name": "corelib_usage.cairo"
    }
  },
  {
    "pageContent": "enum MyEnumShort {\n    a: felt252,\n    b: felt252\n}\nenum MyEnumLong {\n    a: felt252,\n    b: felt252,\n    c: felt252\n}\nenum MyEnumGeneric<S, T> {\n    a: T,\n    b: S,\n    c: T\n}\n\nimpl MyEnumGenericDrop of Drop::<MyEnumGeneric::<(), felt252>>;\n\nfn main() -> felt252 {\n    let es0 = MyEnumShort::a(10);\n    match_short(es0);\n    let es1 = MyEnumShort::b(11);\n    match_short(es1);\n    let el0 = MyEnumLong::a(20);\n    match_long(el0);\n    let el1 = MyEnumLong::b(21);\n    match_long(el1);\n    let el2 = MyEnumLong::c(22);\n    match_long(el2);\n    let eg1: MyEnumGeneric::<(), felt252> = MyEnumGeneric::<(), felt252>::a(30);\n    let eg2: MyEnumGeneric::<(), felt252> = MyEnumGeneric::<(), felt252>::b(());\n    let eg3: MyEnumGeneric::<(), felt252> = MyEnumGeneric::<(), felt252>::c(32);\n    300\n}\n\nfn match_short(e: MyEnumShort) -> felt252 {\n    match e {\n        MyEnumShort::a(x) => {\n            x\n        },\n        MyEnumShort::b(x) => {\n            x\n        },\n    }\n}\n\nfn match_long(e: MyEnumLong) -> felt252 {\n    match e {\n        MyEnumLong::a(x) => {\n            x\n        },\n        MyEnumLong::b(x) => {\n            x\n        },\n        MyEnumLong::c(x) => {\n            x\n        },\n    }\n}\n",
    "metadata": {
      "name": "enum_flow.cairo"
    }
  },
  {
    "pageContent": "// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> felt252 {\n    match n {\n        0 => a,\n        _ => fib(b, a + b, n - 1),\n    }\n}\n",
    "metadata": {
      "name": "fib.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\n// Returns an array of size n with the values of the Fibonacci sequence, the length of the array,\n// and the value of the last element.\nfn fib(n: usize) -> (Array::<felt252>, felt252, usize) {\n    let mut arr = ArrayTrait::new();\n    arr.append(1);\n    arr.append(1);\n    fib_inner(n, ref arr);\n    let len = arr.len();\n    let last = arr.at(len - 1_usize);\n    return (arr, *last, len);\n}\n\nfn fib_inner(n: usize, ref arr: Array::<felt252>) {\n    let length = arr.len();\n    if n <= length {\n        return ();\n    }\n    arr.append(*arr.at(length - 1_usize) + *arr.at(length - 2_usize));\n    fib_inner(n, ref arr)\n}\n",
    "metadata": {
      "name": "fib_array.cairo"
    }
  },
  {
    "pageContent": "use box::BoxTrait;\n\n// Calculates fib, but all variables are boxes.\nfn fib(a: Box::<felt252>, b: Box::<felt252>, n: Box::<felt252>) -> Box::<felt252> {\n    let unboxed_n = n.unbox();\n    if unboxed_n == 0 {\n        a\n    } else {\n        fib(b, BoxTrait::new(a.unbox() + b.unbox()), BoxTrait::new(unboxed_n - 1), )\n    }\n}\n",
    "metadata": {
      "name": "fib_box.cairo"
    }
  },
  {
    "pageContent": "use examples::fib::fib;\nfn fib_caller() {\n    fib(1, 1, 4);\n}\n",
    "metadata": {
      "name": "fib_caller.cairo"
    }
  },
  {
    "pageContent": "// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> (felt252, felt252) {\n    match n {\n        0 => (a, 0),\n        _ => {\n            let (v, count) = fib(b, a + b, n - 1);\n            (v, count + 1)\n        },\n    }\n}\n",
    "metadata": {
      "name": "fib_counter.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\n// Calculates fib...\nfn fib(a: felt252, b: felt252, n: felt252) -> felt252 implicits(RangeCheck, GasBuiltin) {\n    match gas::withdraw_gas() {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('OOG');\n            panic(data);\n        },\n    }\n    match n {\n        0 => a,\n        _ => fib(b, a + b, n - 1),\n    }\n}\n",
    "metadata": {
      "name": "fib_gas.cairo"
    }
  },
  {
    "pageContent": "fn fib(n: felt252) -> felt252 {\n    if n == 0 {\n        1\n    } else if n == 1 {\n        1\n    } else {\n        fib(n - 1) + fib(n - 2)\n    }\n}\n",
    "metadata": {
      "name": "fib_local.cairo"
    }
  },
  {
    "pageContent": "// Calculates fib...\n#[derive(Copy, Drop)]\nstruct FibResult {\n    value: felt252,\n    index: felt252,\n    nothing: ()\n}\n\nfn fib(a: felt252, b: felt252, n: felt252) -> FibResult {\n    match n {\n        0 => FibResult { nothing: (), value: a, index: 0 },\n        _ => {\n            let r = fib(b, a + b, n - 1);\n            FibResult { value: r.value, nothing: (), index: r.index + 1 }\n        },\n    }\n}\n",
    "metadata": {
      "name": "fib_struct.cairo"
    }
  },
  {
    "pageContent": "// Calculates fib...\nfn fib(a: u128, b: u128, n: u128) -> u128 implicits(RangeCheck) {\n    if n == 0_u128 {\n        a\n    } else {\n        fib(b, a + b, n - 1_u128)\n    }\n}\n",
    "metadata": {
      "name": "fib_u128.cairo"
    }
  },
  {
    "pageContent": "// Calculates fib...\nfn fib(a: u128, b: u128, n: u128) -> Option<u128> implicits(RangeCheck) nopanic {\n    // TODO(orizi): Use match on u128 when supported.\n    match integer::u128_to_felt252(n) {\n        0 => Option::Some(a),\n        _ => {\n            let r = fib(\n                b, integer::u128_checked_add(a, b)?, integer::u128_checked_sub(n, 1_u128)?\n            )?;\n            Option::Some(r)\n        },\n    }\n}\n",
    "metadata": {
      "name": "fib_u128_checked.cairo"
    }
  },
  {
    "pageContent": "// Test two level of inline module nesting.\nmod inner {\n    mod inner {\n        fn fib_inner(a: felt252, b: felt252, n: felt252) -> felt252 {\n            if n != 0 {\n                fib_inner(b, a + b, n - 1)\n            } else {\n                a\n            }\n        }\n    }\n}\n\nfn fib(n: felt252) -> felt252 {\n    -inner::inner::fib_inner(-1, -1, n)\n}\n",
    "metadata": {
      "name": "fib_unary.cairo"
    }
  },
  {
    "pageContent": "// Calculates H(...H(H(0, 1), ..., n))...) where H is the Pedersen hash function.\nfn hash_chain(n: felt252) -> felt252 {\n    if n == 0 {\n        return 0;\n    }\n\n    pedersen(hash_chain(n - 1), n)\n}\n",
    "metadata": {
      "name": "hash_chain.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\n// Calculates H(...H(H(0, 1), ..., n))...) where H is the Pedersen hash function.\nfn hash_chain(n: felt252) -> felt252 {\n    if n == 0 {\n        return 0;\n    }\n\n    match gas::withdraw_gas_all(get_builtin_costs()) {\n        Option::Some(x) => {},\n        Option::None(x) => {\n            let mut data = ArrayTrait::new();\n            data.append('Out of gas');\n            panic(data);\n        },\n    }\n\n    pedersen(hash_chain(n - 1), n)\n}\n",
    "metadata": {
      "name": "hash_chain_gas.cairo"
    }
  },
  {
    "pageContent": "mod corelib_usage;\nmod enum_flow;\nmod fib;\nmod fib_array;\nmod fib_box;\nmod fib_caller;\nmod fib_counter;\nmod fib_gas;\nmod fib_local;\nmod fib_struct;\nmod fib_u128_checked;\nmod fib_u128;\nmod fib_unary;\nmod hash_chain_gas;\nmod hash_chain;\nmod pedersen_test;\nmod testing;\n",
    "metadata": {
      "name": "lib.cairo"
    }
  },
  {
    "pageContent": "fn test_pedersen() -> felt252 {\n    pedersen(pedersen(pedersen(1, 2), 3), 4)\n}\n",
    "metadata": {
      "name": "pedersen_test.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\nfn run_tests() {\n    assert(bool::True(()), 1);\n}\n\nfn assert(cond: bool, err_code: felt252) {\n    if cond {} else {\n        let mut data = ArrayTrait::new();\n        data.append(err_code);\n        panic(data);\n    }\n}\n",
    "metadata": {
      "name": "testing.cairo"
    }
  },
  {
    "pageContent": "#[contract]\nmod TestContract {\n    use array::ArrayTrait;\n    use starknet::get_caller_address;\n    use starknet::storage_read_syscall;\n    use starknet::storage_write_syscall;\n    use starknet::syscalls::emit_event_syscall;\n    use starknet::StorageAddress;\n    use starknet::storage_access::storage_base_address_from_felt252;\n    use starknet::storage_access::storage_address_from_base_and_offset;\n    use starknet::ContractAddress;\n\n    struct Storage {\n        my_storage_var: felt252\n    }\n\n    #[external]\n    fn test(ref arg: felt252, arg1: felt252, arg2: felt252) -> felt252 {\n        let x = my_storage_var::read();\n        my_storage_var::write(x + 1);\n        x + 1\n    }\n\n    #[external]\n    fn test_storage_read(address: felt252) -> felt252 {\n        let domain_address = 0_u32; // Only address_domain 0 is currently supported.\n        let storage_address = storage_address_from_base_and_offset(\n            storage_base_address_from_felt252(address), 0_u8\n        );\n        storage_read_syscall(domain_address, storage_address).unwrap_syscall()\n    }\n\n    #[external]\n    fn test_storage_write(address: felt252, value: felt252) {\n        let domain_address = 0_u32; // Only address_domain 0 is currently supported.\n        let storage_address = storage_address_from_base_and_offset(\n            storage_base_address_from_felt252(address), 0_u8\n        );\n        storage_write_syscall(domain_address, storage_address, value).unwrap_syscall();\n    }\n\n    #[external]\n    fn test_get_caller_address() -> ContractAddress {\n        let caller_address = get_caller_address();\n        caller_address\n    }\n\n    #[external]\n    fn test_emit_event(keys: Array::<felt252>, data: Array::<felt252>) {\n        emit_event_syscall(keys.span(), data.span()).unwrap_syscall();\n    }\n\n    #[external]\n    fn test_emit_simple_event(arg0: felt252) {}\n}\n",
    "metadata": {
      "name": "inconsistent_gas.cairo"
    }
  },
  {
    "pageContent": "use starknet::contract_address::ContractAddressSerde;\n\n#[abi]\ntrait IProxy {\n    fn initialize(world_address: starknet::ContractAddress);\n}\n",
    "metadata": {
      "name": "issue2114.cairo"
    }
  },
  {
    "pageContent": "use hash::LegacyHash;\nuse integer::u256_from_felt252;\n\n#[test]\nfn test_bug_test() {\n    let a = 1;\n    let b = 2;\n    let mut c = 0;\n    if u256_from_felt252(\n        a\n    ) < u256_from_felt252(b) {\n        c = LegacyHash::hash(a, b);\n    } else {\n        c = LegacyHash::hash(b, a);\n    }\n}\n",
    "metadata": {
      "name": "issue2147.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nuse hash::LegacyHash;\nuse integer::u256_from_felt252;\nuse option::OptionTrait;\n\nfn reproduce_bug() {\n    match gas::withdraw_gas_all(get_builtin_costs()) {\n        Option::Some(_) => {},\n        Option::None(_) => {\n            let mut data = ArrayTrait::new();\n            data.append('OOG');\n            panic(data);\n        }\n    }\n    let a = 1;\n    let b = 2;\n    let mut c = 0;\n    if u256_from_felt252(\n        a\n    ) < u256_from_felt252(b) {\n        c = LegacyHash::hash(a, b);\n    } else {\n        c = LegacyHash::hash(b, a);\n    }\n}\n",
    "metadata": {
      "name": "issue2152.cairo"
    }
  },
  {
    "pageContent": "use traits::Into;\nuse starknet::ContractAddressIntoFelt252;\n\nfn foo(contract_address: starknet::ContractAddress) {\n    assert(contract_address.into() == contract_address.into(), 'Some message');\n}\n",
    "metadata": {
      "name": "issue2171.cairo"
    }
  },
  {
    "pageContent": "use box::BoxTrait;\n\nstruct Node {\n    value: felt252,\n    left: Option<Box<Node>>,\n    right: Option<Box<Node>>,\n}\n\nfn traverse(node: Node) nopanic {\n    let Node{value, left, right } = node;\n    match left {\n        Option::Some(x) => traverse(x.unbox()),\n        Option::None(_) => {},\n    }\n    match right {\n        Option::Some(x) => traverse(x.unbox()),\n        Option::None(_) => {},\n    }\n}\n",
    "metadata": {
      "name": "issue2172.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\nfn main() {\n    let mut a = ArrayTrait::<felt252>::new();\n    assert(a.len() == 0_usize, 'Array length is not 0');\n    assert(a.is_empty() == true, 'Array is not empty');\n}\n",
    "metadata": {
      "name": "issue2176.cairo"
    }
  },
  {
    "pageContent": "use array::ArrayTrait;\n\n#[derive(Drop)]\nstruct MyStruct {\n    value: felt252,\n    arr: Array<felt252>\n}\n\n#[test]\nfn main() {\n    let mut my_struct = MyStruct { value: 0, arr: ArrayTrait::<felt252>::new() };\n    let result = sub_three(my_struct.value);\n    my_struct.value = result;\n}\n\nfn sub_three(value: felt252) -> felt252 {\n    value - 3\n}\n",
    "metadata": {
      "name": "issue2530.cairo"
    }
  },
  {
    "pageContent": "mod issue2114;\nmod issue2147;\nmod issue2152;\nmod issue2171;\nmod issue2172;\nmod issue2176;\nmod issue2530;\nmod partial_param_local;\nmod inconsistent_gas;\n",
    "metadata": {
      "name": "lib.cairo"
    }
  },
  {
    "pageContent": "struct strct {\n    x: felt252\n}\n\n#[test]\nfn test_foo() -> felt252 {\n    let x = strct { x: 12 }.x;\n    internal::revoke_ap_tracking();\n    x\n}\n",
    "metadata": {
      "name": "partial_param_local.cairo"
    }
  }
]